# Preservando a Integridade do Modelo
 
Este capítulo trata de grandes projetos que requerem a combinação de esforços entre várias equipes distintas. Enfrentamos muitos desafios quando várias equipes, com administração e coordenação heterogêneas, são incumbidas de desenvolver um projeto. Projetos corporativos são geralmente grandes e empregam diversificados recursos e tecnologias. O design de tais projetos deveria ser baseado em um modelo de domínio, pois precisamos tomar medidas adequadas para garantir o sucesso do projeto.
 
Quando várias equipes trabalham em um projeto, o desenvolvimento do código é feito em paralelo e a cada equipe é atribuída uma parte específica do modelo. As partes não são independentes, mas são mais ou menos interligadas. Todas elas começam com um modelo grande, que é compartilhado entre as equipes, para ser implementado. Digamos que uma das equipes criou um módulo, já disponibilizado para utilização por outras equipes. Um desenvolvedor de outra equipe começa a usar o módulo e descobre que está faltando alguma funcionalidade necessária para o seu próprio módulo. Ele acrescenta a funcionalidade necessária e atualiza o código para que possa ser usado por todos. Contudo, ele não percebe que essa mudança realmente afetará o modelo, sendo bem provável que haja danos na funcionalidade do aplicativo. Isso pode acontecer facilmente, pois ninguém gasta tempo tentando entender todo o modelo. As pessoas conhecem o seu próprio quintal, mas outras regiões não são conhecidas com detalhes suficientes.
 
É tão fácil começar a partir de um modelo bom que vai regredindo para um que seja inconsistente. O requisito principal de um modelo deve ser a sua consistência, com termos invariáveis e sem contradições. A consistência interna de um modelo é chamada de unificação. Um projeto corporativo poderia ter um modelo que cobre todo o domínio da empresa, sem contradições e sobreposições de termos. Um modelo corporativo unificado é um ideal que não é facilmente alcançado. Às vezes, nem vale a pena tentar alcançá-lo.
 
Esses projetos necessitam do esforço combinado de muitas equipes, que precisam de um elevado grau de independência no processo de desenvolvimento, pois não têm tempo para constantemente se reunir e discutir sobre o design. A coordenação dessas equipes é uma tarefa difícil, já que podem pertencer a diferentes departamentos e ter gestão separada.
 
Quando o design do modelo evolui parcialmente, de forma independente, há a possibilidade de se perder a integridade do modelo como um todo. Preservar a sua integridade a partir do esforço de se manter um grande modelo unificado para todo o projeto corporativo não será uma boa saída. A solução não é tão óbvia, pois é o oposto de tudo o que aprendemos até agora: em vez de tentar manter um modelo grande que vai desmoronar mais tarde, devemos, conscientemente, dividi-lo em vários modelos de tal modo que, por serem bem integrados, podem evoluir de forma independente, desde que obedeçam ao contrato a que são vinculados. Cada modelo deve ter uma fronteira claramente delimitada e as relações entre os modelos devem ser definidas com precisão.
 
Vamos apresentar um conjunto de técnicas utilizadas para manter a integridade do modelo. A figura a seguir apresenta estas técnicas e a relação entre elas.

## Contexto Delimitado
 
Cada modelo tem um contexto. Quando lidamos com um único modelo, o contexto é implícito, não precisamos delimitá-lo. Quando criamos um aplicativo que deverá interagir com outros softwares, por exemplo, um aplicativo legado, fica claro que a nova aplicação tem seu próprio modelo e contexto, que é separado do contexto do modelo legado. Eles não podem ser combinados, misturados ou confundidos. Mas quando trabalhamos com grandes aplicações corporativas, precisamos definir o contexto de cada modelo que criarmos.
 
Vários modelos estão em jogo em qualquer projeto de grande porte. No entanto, quando os códigos baseados em modelos distintos são combinados, o software se torna defeituoso, não confiável e de difícil compreensão. A comunicação entre os membros da equipe tende a se tornar confusa. Nem sempre fica claro em que contexto o modelo deva ser aplicado.
 
Não existe uma fórmula para dividir um grande modelo em menores. Tente colocar em um modelo os elementos que estão relacionados a ele e que formem um conceito natural. Um modelo deve ser suficientemente pequeno para ser atribuído a uma equipe. A cooperação da equipe e comunicação será mais fluida e completa, auxiliando os desenvolvedores que estão trabalhando no mesmo modelo. O contexto de um modelo é o conjunto de condições que precisam ser aplicadas para se certificar que os termos utilizados no modelo têm um significado específico.
 
A ideia principal é definir o escopo de um modelo para elaborar os limites do seu contexto, em seguida, fazer o máximo possível para manter o modelo unificado. É difícil manter um modelo puro, quando se mede o projeto corporativo inteiro, mas é muito mais fácil quando se está limitado a uma área específica. Defina explicitamente o contexto ao qual o modelo se aplica. Defina claramente limites em termos de organização de equipe, de partes específicas da aplicação e de manifestações físicas, tais como bases de código e esquemas de banco de dados. Mantenha o modelo estritamente coerente dentro desses limites, mas não se distraia ou confunda por questões alheias.
 
Um Contexto Delimitado não é um Módulo. Fornece um quadro lógico dentro do qual o modelo evolui. Módulos são usados ​​para organizar os elementos de um modelo, assim, os Contextos Delimitados englobam os Módulos.
 
Quando equipes diferentes têm que trabalhar no mesmo modelo, devemos ter muito cuidado para não se pisar no pé de ninguém. Temos que ser sempre conscientes de que mudanças no modelo podem chegar a inutilizar funcionalidades existentes. Ao usar vários modelos, todos podem trabalhar livremente em sua própria parte. Sabemos quais são os limites de nosso modelo, permanecendo dentro das fronteiras. Apenas temos que ter certeza de que estamos mantendo o modelo puro, consistente e unificado. Cada modelo deve permitir uma refatoração fácil, sem repercussões em outros modelos. Dessa maneira, o projeto pode ser refinado e destilado, a fim de alcançar a máxima pureza.
 
Ter vários modelos exige um preço a se pagar. Precisamos definir as fronteiras e as relações entre diferentes modelos. Isso requer trabalho e esforço extra de projeto, exigindo, talvez, alguma tradução entre modelos diferentes. Não seremos capazes de transferir objetos entre diferentes modelos e não poderemos invocar o comportamento livremente como se não houvesse limites. Mas essa não é uma tarefa muito difícil e os benefícios valem a pena.
 
Por exemplo, queremos criar um aplicativo de comércio eletrônico utilizado para vender coisas na Internet. Essa aplicação permite que os clientes se registrem e informem os seus dados pessoais, incluindo números de cartão de crédito. Os dados são mantidos em um banco de dados relacional. Os clientes registrados serão autorizados a entrar e navegar no site à procura de mercadorias e encomendas. O aplicativo terá a necessidade de enviar um evento sempre que uma ordem de compra for solicitada, pois alguém vai ter que enviar o item comprado. Também queremos construir uma interface gráfica usada para criar relatórios, com o intuito de monitorar o estado dos bens disponíveis, o que os clientes estão interessados em comprar, o que eles não gostam etc. No começo, começamos com um modelo que cobre todo o domínio do comércio eletrônico. Somos tentados a fazê-lo, porque foi solicitado criar uma grande aplicação. Mas se considerarmos a tarefa mais cuidadosamente, descobriremos que a aplicação de comércio eletrônico não está realmente relacionada com a interface para relatórios. Eles têm preocupações distintas, operam com conceitos diferentes e pode até mesmo necessitar usar tecnologias diferentes. A única coisa realmente em comum é que o cliente e os dados da mercadoria são mantidos no banco de dados e ambas as aplicações precisam acessá-los.
 
A abordagem recomendada é criar um modelo separado para cada um dos domínios, um para o comércio eletrônico e outro para os relatórios. Eles podem evoluir livremente, sem muita preocupação uns com os outros, até mesmo se tornarem aplicativos separados. Pode haver o caso em que a aplicação de relatórios precise de alguns dados específicos que o aplicativo de comércio eletrônico terá de armazenar no banco de dados, mas caso contrário, eles podem crescer de forma independente.
 
Um sistema de mensagens é necessário para informar aos funcionários do estoque sobre as encomendas realizadas, para que possam enviar a mercadoria aos compradores. Eles irão usar uma aplicação de e-mail que lhes fornecerá informações detalhadas sobre o item comprado, a quantidade, o endereço do cliente e os requisitos de entrega. Não há necessidade que o modelo de comércio eletrônico cubra ambos os domínios de atividade. É muito mais simples para o aplicativo de comércio eletrônico enviar Objetos de Valor contendo informações da compra para os funcionários do estoque através de mensagens assíncronas. Há, definitivamente, dois modelos que podem ser desenvolvidos separadamente. Precisamos apenas ter certeza de que a interface entre eles funcione corretamente.

## Integração Contínua
 
Uma vez definido o Contexto Delimitado, deveremos mantê-lo sólido. Quando certo número de pessoas estiver trabalhando no mesmo Contexto Delimitado, há uma forte tendência de se fragmentar o modelo. Quanto maior a equipe, maior o problema, mas mesmo com uma equipe de apenas três ou quatro pessoas ainda estaremos sujeitos a esses problemas.
 
No entanto, quebrar o sistema em contextos cada vez menores faz com que se perca um valioso nível de integração e de coerência.
 
Mesmo quando uma equipe trabalha em um único Contexto Delimitado, há chances dos erros acontecerem. Precisamos nos comunicar dentro da equipe para ter certeza de que todos entendam o papel desempenhado por cada elemento do modelo. Caso não se entenda as relações entre os objetos, a equipe poderá modificar o código de tal forma que entrará em contradição com a intenção original do modelo Quando não se está focado 100% na pureza do modelo, esse erro se torna comum. Um membro da equipe pode adicionar código que duplica outros códigos que não conheça, ou fazem isso intencionalmente com medo de introduzir falhas nas funcionalidades já existentes.
 
Um modelo não está totalmente definido desde o início. Ele é criado e evolui continuamente com base em uma nova visão no domínio e no feedback do processo de desenvolvimento. Isso significa que novos conceitos podem entrar no modelo e novos elementos podem ser adicionados ao código. Todos eles devem ser integrados em um modelo unificado, implementado corretamente. É por isso que a Integração Contínua é um processo necessário dentro de um Contexto Delimitado. Precisamos de um processo de integração para se certificar de que todos os novos elementos que são adicionados se encaixam harmoniosamente com o restante do modelo, sendo implementados corretamente no código. Precisamos ter um procedimento padrão para se realizar o merge no código. Quanto mais cedo fizermos o merge, melhor. Para uma única equipe pequena, são recomendados merges diários. Nós também precisamos ter um processo de build de aplicações consolidado. O código que passou pelo processo de merge automaticamente precisa ter seu build gerado, para que possa ser testado. Outro requisito necessário é a realização de testes automatizados. Se a equipe tem uma ferramenta de teste e criou um conjunto de testes, a cada build ele pode ser executado para que os erros sejam identificados. O código pode ser facilmente alterado para corrigir os erros relatados, pois eles são capturados logo cedo. O merge, build e processo de teste são iniciados novamente.
 
A Integração Contínua se baseia na agregação de conceitos do modelo, para encontrar o seu caminho na implementação, onde realmente é testado. Qualquer inconsistência do modelo pode ser visualizada na implementação. A Integração Contínua se aplica dentro de um Contexto Delimitado, não sendo usado para lidar com as relações entre Contextos vizinhos.


## Mapa de Contextos
 
Um aplicativo corporativo tem vários modelos, cada qual tendo o seu próprio Contexto Delimitado. É aconselhável usar o contexto como base para a organização da equipe. Pessoas na mesma equipe podem se comunicar mais facilmente, podendo fazer um melhor trabalho de integração do modelo e de implementação. Ainda que todas as equipes trabalhem com seus respectivos modelos, é interessante que todos tenham uma ideia geral do todo. Um Mapa de Contexto é um documento que descreve os diferentes Contextos Delimitados e as relações entre eles. Um Mapa de Contexto pode ser um diagrama conforme abaixo, ou pode ser qualquer documento escrito. O nível de detalhe pode variar. O mais importante é que todos os que trabalhem sobre as ações do projeto entendam-no.
 
 
Não é o bastante ter modelos unificados separados. Eles têm que ser integrados, pois a funcionalidade de cada modelo é apenas uma parte de todo o sistema. No final, as peças devem ser montadas juntas e todo o sistema deverá funcionar corretamente. Se os contextos não estão claramente definidos, é possível que eles sobreponham uns aos outros. Se as relações entre os contextos não são descritas, há uma grande chance de se encontrar falhas quando o sistema for integrado.
 
Todo Contexto Delimitado deve ter um nome que faça parte da Linguagem Ubíqua. Isso ajuda muito na comunicação da equipe quando se falar do sistema por completo. Todos devem conhecer os limites de cada contexto e o mapeamento entre contexto e código. Uma prática comum é definir os contextos para, em seguida, criar módulos dentro deles, usando uma convenção de nomenclatura para indicar o contexto a que cada módulo pertence.
 
Nas páginas seguintes, falaremos sobre a interação entre diferentes contextos. Apresentaremos uma série de padrões que podem ser usados para criar Mapas de Contexto, onde cada contexto tem um papel claro e seus relacionamentos são apontados. O Núcleo Compartilhado e o Produtor-Consumidor são padrões com elevado grau de interação entre os contextos. Caminhos Separados é um padrão utilizado quando se quer ter contextos altamente independentes, evoluindo separadamente. Outros dois padrões para se lidar com a interação com sistemas legados ou sistemas externos são os Serviços Open Host e a Camada de Anticorrupção.


## Núcleo Compartilhado
 
Quando a integração funcional é limitada, a sobrecarga na Integração Contínua pode ser considerada muito alta. Isso pode ser constatado quando as equipes não têm a habilidade ou a organização política para manter a integração contínua, ou quando uma única equipe é simplesmente muito grande e densa. Assim, distintos Contextos Delimitados podem ser definidos e várias equipes formadas.
 
Equipes descoordenadas, trabalhando em aplicações que são correlatas, poderão avançar por um tempo, mas o que eles produzirem poderá não se encaixar. Eles podem acabar gastando mais esforço nas camadas de tradução e adaptação do que gastariam caso sempre usassem a Integração Contínua, além de duplicar os esforços e perder os benefícios de uma Linguagem Ubíqua comum.
 
Portanto, escolha um subconjunto do modelo de domínio o qual as duas equipes concordem compartilhar. Claro que isso inclui, junto ao subconjunto do modelo, o subconjunto de código ou do design de banco de dados associado a essa parte do modelo. Esse material compartilhado explicitamente tem um status especial, não devendo ser alterado sem consulta com a outra equipe.
 
Integre com frequência um sistema funcional, mas um pouco menos frequentemente do que o ritmo da Integração Contínua dentro das equipes. Durante essas integrações, execute os testes de ambas as equipes.
 
O objetivo do Núcleo Compartilhado é reduzir a duplicação, mantendo dois contextos distintos. O desenvolvimento de um Núcleo Compartilhado precisa de muito cuidado. Ambas as equipes podem modificar o núcleo do código, fazendo com que precisem integrar as alterações. Se as equipes utilizam cópias em separado do núcleo do código, eles têm de realizar o merge no código o mais rapidamente possível, pelo menos semanalmente. O conjunto de testes deve ser efetivo, para que cada mudança feita no núcleo seja imediatamente testada e auferida. Qualquer alteração no núcleo deve ser comunicada à outra equipe, estando todas bem informadas, cientes da nova funcionalidade.
Produtor-Consumidor
Há momentos em que dois subsistemas têm um relacionamento especial: um depende muito do outro. Os contextos que contemplam dois subsistemas são diferentes e o resultado do processamento de um sistema alimenta o outro. Eles não possuem um núcleo compartilhado, pois não faz parte do conceito deles ou por ser tecnicamente inviável o compartilhamento do código comum. Os dois subsistemas estão em um relacionamento Produtor-Consumidor.
 
Vamos voltar ao exemplo anterior. Falamos sobre modelos envolvidos em um aplicativo de comércio eletrônico, que inclui relatórios e mensagens. Já dissemos que é muito melhor criar modelos separados para todos esses contextos, pois um único modelo seria um gargalo constante, fonte de discórdia no processo de desenvolvimento. Supondo que estamos de acordo em termos modelos distintos, como devem ser as relações entre o subsistema de comércio eletrônico web e o de relatórios? O Núcleo Compartilhado não parece ser uma boa escolha, pois os subsistemas poderão usar diferentes tecnologias de implementação. Um deles é uma experiência de browser puro, enquanto o outro poderia ser uma rica aplicação GUI. Mesmo que o subsistema de relatório seja feito através de uma interface web, os principais conceitos dos respectivos modelos serão diferentes. Pode haver alguma sobreposição, mas não o suficiente para justificar um Núcleo Compartilhado. Então, decidimos escolher ir por um caminho diferente. Por outro lado, o subsistema de comércio eletrônico não depende do subsistema de relatório. Os usuários do aplicativo de comércio eletrônico são os clientes web que navegam pelas mercadorias, fazendo pedidos. Todos os dados do cliente, mercadoria e os pedidos são inseridos em um banco de dados. E é isso. A aplicação de comércio eletrônico não está realmente interessada no que acontece com esses dados. Enquanto isso, a aplicação de relatórios pode estar muito interessada e precisar desses dados salvos pelo aplicativo de comércio eletrônico. Pode também precisar de algumas informações extras para prover serviços de relatório específicos. Os clientes podem adicionar alguma mercadoria na cesta e depois largá-la antes da finalização da compra. Podem visitar alguns links mais do que outros. Esse tipo de informação não tem nenhum significado para a aplicação de comércio eletrônico, mas pode significar muito para a aplicação de relatório. Com isso em mente, o subsistema produtor precisa implementar algumas especificações que são necessárias pelo subsistema consumidor. Essa será a conexão entre os dois subsistemas.
 
Outro requisito está relacionado ao banco de dados utilizado, mais precisamente o seu esquema. Ambos os aplicativos farão uso do mesmo banco de dados. Se o subsistema de comércio eletrônico fosse o único a acessar o banco de dados, o seu esquema poderia ser mudado a qualquer momento para refletir as necessidades. Mas o subsistema de relatório também precisa acessar o banco de dados, então ele precisa de alguma estabilidade nesse esquema. É impossível imaginar que o esquema de banco de dados não vai mudar durante todo o processo de desenvolvimento. Isso não vai representar um problema para o aplicativo de comércio eletrônico, mas certamente será um problema para o de relatórios. As duas equipes terão que se comunicar, pois trabalharão no banco de dados juntos, decidindo se a mudança será ou não realizada. Isso irá atuar como uma limitação para o subsistema de relatórios, pois a respectiva equipe pode preferir fazer as mudanças rapidamente e avançar no desenvolvimento, em vez de esperar no aplicativo comércio eletrônico. Se a equipe de comércio eletrônico tem direito de veto, pode impor limites às mudanças a serem feitas no banco de dados, prejudicando as atividades da equipe de relatório. Se a equipe de comércio eletrônico puder agir de forma independente, poderá quebrar os acordos mais cedo ou mais tarde, implementando algumas alterações para as quais a equipe de relatório não está preparada. Esse padrão funciona bem quando as equipes estão sob a mesma gestão. Isso facilita o processo decisório e cria harmonia.
 
Quando somos confrontados com uma situação como essa, devemos começar a agir. A equipe de relatório deverá desempenhar o papel de consumidor, enquanto a equipe de comércio eletrônico desempenhará o papel de produtor. As duas equipes devem se reunir regularmente ou a pedido para discutirem exatamente como um consumidor deverá trabalhar com o seu produtor (fornecedor). A equipe do consumidor deve apresentar os seus requisitos, enquanto a equipe produtora deverá fazer os planos de conformidade. Já que todos os requisitos da equipe do consumidor terão de ser cumpridos, ao final, o calendário para fazer isso é decidido pela equipe do produtor. Se alguns requisitos forem considerados realmente importantes, eles devem ser implementados mais cedo, enquanto outros requisitos podem ser adiados. A equipe do consumidor também necessita estar a par do conhecimento compartilhado pela equipe do produtor. O fluxo desse processo é numa única direção, sendo necessário em alguns casos.
 
A interface entre os dois subsistemas precisa ser precisamente definida. Um conjunto de testes de conformidade deve ser criado e utilizado para verificar, a qualquer momento, se os requisitos da interface são respeitados. A equipe do produtor será capaz de trabalhar livremente em seus projetos, pois a segura rede de interfaces para o conjunto de testes sempre alerta quando há um problema.
 
Estabeleça uma clara relação de consumidor / produtor entre as duas equipes. Nas sessões de planejamento, faça com que a equipe do consumidor desempenhe o papel de cliente para a equipe de produtor. Negocie e estime as tarefas para os requisitos do cliente de tal modo que todos compreendam os compromissos e cronograma.
 
Desenvolva conjuntamente os testes de aceitação automatizados que irão validar a interface esperada. Adicione esses testes ao conjunto de testes da equipe do produtor, a fim de que sejam executados como parte de sua integração contínua. Esses testes liberarão a equipe do produtor para fazer as mudanças, sem medo dos efeitos colaterais na aplicação da equipe do consumidor. 


## Conformista
 
A relação Produtor-Consumidor é viável quando ambas as equipes são interessadas ​​nesse relacionamento, onde o consumidor é muito dependente do produtor, embora esse não seja dependente do primeiro. Se houver uma gestão compromissada com esse trabalho, o produtor deverá ter a atenção necessária para ouvir os pedidos do consumidor. Se a gestão não decidiu claramente como as coisas funcionarão entre as duas equipes, se há má gestão ou se há a falta dela, o produtor lentamente focará em seu modelo e design, estando menos interessado em ajudar ao consumidor, afinal eles têm seus próprios prazos. Mesmo que a equipe seja composta por pessoas boas, dispostas a ajudar o outro time, a pressão do tempo pesará, prejudicando a equipe consumidora. Isso acontece também quando as equipes pertencem a empresas diferentes, onde a comunicação é difícil. A empresa do produtor não estará muito interessada em investir nessa relação, fornecendo ajuda esporádica ou simplesmente se recusando a cooperar em tudo. O resultado é que a equipe do consumidor estará por sua conta e risco, tentando fazer o seu melhor para evoluir o modelo e o design.
 
Quando duas equipes de desenvolvimento têm uma relação Produtor-Consumidor em que a equipe do produtor não tem motivação para prover as necessidades da equipe do consumidor, essa fica desamparada. Altruísmo pode motivar os desenvolvedores do produtor a fazer promessas, mas é pouco provável que sejam cumpridas. A crença nas boas intenções faz com que a equipe do consumidor planeje com base em funcionalidades que nunca estarão disponíveis. O projeto do consumidor será adiado até que a equipe finalmente aprenda a viver com o que é dado. Uma interface adaptada às necessidades da equipe do consumidor não é um bônus fácil de conseguir.
 
A equipe do consumidor tem algumas opções. A mais óbvia é a de se separar do produtor para ser completamente independente. Veremos isso mais tarde no padrão denominado Caminhos Separados. Às vezes, os benefícios proporcionados pelo subsistema de produtor não valem a pena, sendo mais simples criar um modelo e design separados, sem ter que dar satisfação ao produtor. Mas nem sempre esse é o caso. Às vezes, há algo de valor no modelo do produtor, cuja ligação deverá ser mantida. Mas já que a equipe do produtor não ajuda a equipe do consumidor, essa última terá que tomar algumas medidas para se proteger de mudanças no modelo realizadas pela primeira equipe. Precisarão implementar uma camada de tradução que ligue os dois contextos. Também é possível que o modelo da equipe do produtor seja mal concebido tornando sua utilização estranha. O contexto do consumidor ainda pode fazer uso desse modelo, mas deverá se proteger usando uma Camada de Anticorrupção, que discutiremos mais tarde.
 
Se o consumidor tem que usar o modelo da equipe do produtor, isso tem que ser bem feito, pois pode ser chegada a hora de usar o Conformismo. A equipe do consumidor poderia aderir ao modelo da equipe do produtor, se adaptando inteiramente a ele. Isso é muito parecido com o padrão Núcleo Compartilhado, mas há uma diferença importante: a equipe do consumidor não poderá fazer alterações no núcleo. Eles só poderão usá-lo como parte de seu modelo, trabalhando a partir do código existente fornecido. Existem muitos momentos em que tal solução é viável. Quando alguém oferece um componente rico, e fornece uma interface para ele, podemos construir o nosso modelo, incluindo o respectivo componente como se fosse o nosso próprio. Se o componente tem uma interface mínima, será melhor criar um adaptador para ele, para traduzir o nosso modelo para o modelo do componente. Isso isolaria nosso modelo de tal forma que poderíamos desenvolvê-lo com um alto grau de liberdade.


## Camada de Anticorrupção
 
Muitas vezes encontramos situações em que criamos uma aplicação que deva interagir com um software legado ou um aplicativo externo. Esse é outro desafio para o modelador de domínios, pois muitas aplicações legadas não foram construídas utilizando técnicas de modelagem de domínio. Seus modelos são confusos, emaranhados, difíceis de entender e de trabalhar. Mesmo que o modelo das aplicações legadas seja bem feito, pode não ser muito útil para nós, já que provavelmente nosso modelo será diferente. No entanto, tem que haver um nível de integração entre o nosso modelo e o legado, pois um dos requisitos é fazer uso da aplicação antiga.
 
Existem diferentes maneiras de o nosso sistema consumidor interagir com o aplicativo externo. Uma delas é através de conexões de rede. Ambos os aplicativos necessitam usar os mesmos protocolos de comunicação e o consumidor precisa aderir à interface usada pelo sistema externo. Outro método de interação é através da base de dados. O sistema externo trabalha com dados armazenados em um banco de dados. O sistema consumidor deverá acessar esse mesmo banco. Em ambos os casos, estamos lidando com dados primitivos sendo transferidos entre os sistemas. Enquanto isso parece ser bastante simples, a verdade é que dados primitivos não contém qualquer informação sobre os modelos. Não podemos pegar os dados de um banco de dados e tratá-los todos como se fossem dados primitivos. Existe uma grande quantidade de semântica escondida atrás de um dado. Um banco de dados relacional contém dados primitivos relacionados a outros dados primitivos, criando uma rede de relacionamento. A semântica dos dados é muito importante e precisa ser considerada. O aplicativo consumidor não pode acessar o banco de dados e escrever nele sem entender o significado dos dados trabalhados. Veremos que partes do modelo externo serão refletidas no banco de dados, afetando o nosso modelo.
 
Existe o risco de o modelo externo alterar o modelo consumidor caso isso seja permitido. Não podemos ignorar a interação com o modelo externo, mas devemos ter o cuidado de isolá-lo do nosso próprio modelo. Devemos construir uma Camada de Anticorrupção que se interponha entre o nosso modelo consumidor e o outro externo. Da nossa perspectiva de modelo, a Camada de Anticorrupção é uma parte natural do modelo, não se tornando algo estranho a ele. Ela opera com conceitos e ações familiares ao nosso modelo. Todavia, a Camada de Anticorrupção conversa com o modelo externo usando uma linguagem externa e não a linguagem do consumidor. Essa camada funciona como um tradutor entre os dois domínios e linguagens. O maior ganho nisso é que o modelo consumidor permanecerá puro e consistente, sem ser contaminado pelo modelo externo.
 
Como devemos implementar a Camada de Anticorrupção? Uma solução muito boa é ver essa camada como um serviço do modelo consumidor. É muito fácil de usar um serviço, pois ele abstrai o outro sistema, permitindo que lidemos com esse sistema usando nossos próprios termos. O Serviço fará a tradução necessária, mantendo nosso modelo isolado. Sobre a implementação real do serviço, usaremos uma Fachada (ver Design Pattern por Gamma et al. 1995). Além disso, a Camada de Anticorrupção provavelmente irá precisar de um Adaptador. O Adaptador permite converter a interface de uma classe para uma que o consumidor entenda. No nosso caso, o Adaptador não será, necessariamente, o wrapper de uma classe, pois seu trabalho será realizar a tradução entre dois sistemas.
 
 
A Camada de Anticorrupção pode conter mais de um Serviço. Para cada serviço há uma Fachada correspondente, e, para cada Fachada, adicionaremos um adaptador. Não devemos usar um adaptador único para todos os serviços, pois poderemos sobrecarregá-lo com funcionalidades muito diversificadas.
 
Ainda temos que acrescentar mais um componente: o Adaptador, que abstrai o comportamento do sistema externo. Necessitamos ainda da conversão de objetos e dados. Isso é feito usando um tradutor.
 
O tradutor será um objeto muito simples, com poucas funcionalidades, servindo apenas à necessidade básica de tradução de dados. Se o sistema externo tem uma interface complexa, é melhor adicionar uma Fachada sobressalente entre os adaptadores e a interface. Isso simplifica o protocolo do Adaptador, separando-o do outro sistema.
Caminhos Separados
 
Até agora, tentamos encontrar maneiras de integrar os subsistemas, fazendo com que eles trabalhem juntos, de modo que o modelo e o design se mantenham incólumes. Isso requer esforço e compromisso. As equipes que trabalham nos respectivos subsistemas necessitam gastar um tempo considerável para elucidar o relacionamento existente entre os subsistemas. Precisam fazer constante merge de código e realizar testes para ter certeza de que não introduziram bugs. Às vezes, uma das equipes precisa implementar alguns requisitos que sejam necessários ao outro time. Existe um compromisso a ser seguido. Uma coisa é desenvolver de forma independente, escolher os conceitos e associações livremente; outra coisa bem diferente é se certificar de que o seu modelo se encaixa no framework do outro sistema. Talvez precisemos alterar o modelo só para fazê-lo funcionar com o outro subsistema. Precisamos, então, introduzir camadas especiais que realizam traduções entre os dois subsistemas. Há momentos em que é necessário fazer isso, mas há momentos em que podemos percorrer um Caminho Separado. Temos que avaliar cuidadosamente os benefícios da integração e usá-la apenas se houver real necessidade em fazê-lo. Se chegarmos à conclusão de que a integração é mais problemática do que vantajosa, então deveremos usar os Caminhos Separados.
 
O padrão Caminhos Separados trata o caso de haver uma aplicação empresarial que emerge de várias aplicações menores que pouco ou nada têm em comum, numa perspectiva de modelagem. Existe um único conjunto de requisitos e do ponto de vista do usuário é apenas uma aplicação, mas do ponto de vista de modelagem e design podem existir modelos separados com implementações distintas. Devemos olhar para os requisitos e ver se eles podem ser divididos em dois ou mais conjuntos que não têm muito em comum. Se isso puder ser feito, então podemos criar Contextos Delimitados separados e trabalhar na modelagem de forma independente. A vantagem disso é ter a liberdade de escolher as tecnologias para a implementação. As aplicações que estamos criando podem compartilhar uma interface gráfica em comum, que funciona como um portal com links ou botões usados ​​para acessar cada aplicação. É uma integração menor que tem a ver com a organização das aplicações, ao invés do modelo por trás delas.
 
Antes de usar os Caminhos Separados, precisamos ter certeza de que não voltaremos atrás nessa decisão, buscando um sistema integrado. Modelos desenvolvidos de forma independente são muito difíceis de integrar. Eles terão muito pouco em comum, não valendo a pena fazer a integração.
Serviço Open Host
 
Quando tentamos integrar dois subsistemas, normalmente criamos uma camada de tradução entre eles. Essa camada age como um buffer entre o subsistema consumidor e o subsistema externo que queremos integrar. Essa camada pode ser consistente, dependendo da complexidade das relações e de como o subsistema externo foi projetado. Se o subsistema externo muda de tal forma para ser utilizado não apenas por um subsistema consumidor, mas por outros diversos, precisaremos criar camadas de tradução para todos eles. Todas elas irão repetir a mesma tarefa de tradução, contendo código semelhante.
 
Quando um subsistema deve ser integrado com muitos outros, personalizar um tradutor para cada um pode consumir demasiado tempo da equipe. Haverá cada vez mais código para ser mantido, aumentando a preocupação quando as alterações forem feitas.
 
A solução é ver o subsistema externo como provedor de serviços. Se nós pudermos abstrair um conjunto de Serviços ao seu redor, então todos os outros subsistemas irão acessar esses Serviços, sem precisar de qualquer camada de tradução. A dificuldade é que cada subsistema necessita interagir de uma maneira específica com o subsistema externo, e criar um conjunto coerente de Serviços tende a ser problemático.
 
Defina um protocolo que dá acesso ao seu subsistema como um conjunto de Serviços. Abra o protocolo de forma que todos os que precisem integrar com você possa utilizá-lo. Melhore e expanda o protocolo para lidar com novos requisitos de integração, exceto quando uma única equipe tem necessidades idiossincráticas. Então, use um tradutor externo para incrementar o protocolo nesse caso especial em que o protocolo sendo compartilhado pode permanecer simples e coerente.

## Destilação
 
Destilação é o processo de separar as substâncias que compõem uma mistura. O objetivo da destilação é extrair uma determinada substância a partir da mistura. Durante esse processo, alguns subprodutos, que também podem ser de nosso interesse, serão obtidos.
 
Um domínio volumoso está associado a um modelo grande, mesmo depois de refinado e criado muitas abstrações. Ele pode permanecer grande, mesmo depois de muitas refatorações. Em situações como essa, pode ser o momento de começar uma Destilação. A ideia é definir um Domínio Núcleo, que representa a essência do domínio. Os subprodutos do processo de destilação serão Subdomínios Genéricos que comprão as outras partes do domínio.
 
Na concepção de um sistema de grande porte, há tantos componentes envolvidos, todos complicados e absolutamente necessários para sucesso, que a essência do modelo de domínio, que é o negócio em si, pode ser obscurecida e negligenciada. Ao trabalhar com um modelo grande, devemos tentar separar os conceitos essenciais dos genéricos. No início, foi dado o exemplo de um sistema de monitoramento de tráfego aéreo. Dissemos que um Plano de Voo contém a Rota que foi designada para o avião seguir. A Rota parece ser um conceito sempre presente nesse sistema. Na verdade, esse conceito é um genérico, e não um essencial. O conceito de Rota é usado em muitos domínios, e um modelo genérico pode ser escolhido para descrevê-lo. A essência do monitoramento de tráfego aéreo está em outro lugar. O sistema de monitoramento conhece a rota que o avião deve seguir, mas também recebe dados de uma rede de radares rastreando o avião no ar. Esses dados mostram o caminho real seguido pelo avião, que geralmente é diferente do prescrito. O sistema terá que calcular a trajetória do avião com base nos parâmetros do seu voo atual, nas características do avião e no tempo. A trajetória é um caminho de quatro dimensões que descreve completamente a rota que o avião vai viajar durante o tempo de voo. A trajetória pode ser computada para os próximos minutos, para as próximas dezenas de minutos ou para as próximas horas. Cada um desses cálculos ajuda no processo decisório. O propósito de calcular a trajetória do avião é para ver se há alguma chance de o avião atravessar o caminho de outro. Muitos aviões estão circulando no ar ou fazendo manobras nas proximidades dos aeroportos, durante a descolagem e aterrisagem. Se um avião se afasta muito do seu percurso planejado, há uma grande possibilidade de um acidente vir a ocorrer. O sistema de monitoramento de tráfego aéreo irá calcular as trajetórias dos aviões e emitirá um alerta se há possibilidade de uma colisão. Os controladores de tráfego aéreo terão que fazer decisões rápidas, direcionando os aviões, a fim de evitar a colisão. Quando os aviões estão mais afastados, as trajetórias são calculadas por longos períodos de tempo, havendo mais tempo para a reação. O módulo que sintetiza a trajetória do avião a partir dos dados disponíveis é o coração do sistema de negócios aqui. Esse deve ser marcado como o Domínio Núcleo. O modelo de rotas é mais um dos Domínios Genéricos.
 
O Domínio Núcleo de um sistema depende de como olhamos para esse sistema. Um sistema de rotas simples verá a Rota e suas dependências como pontos centrais para o design. Já o sistema de monitoramento de tráfego aéreo irá considerar a rota como um subdomínio genérico O Domínio Núcleo de uma aplicação pode se tornar um Subdomínio Genérico de outra. É importante identificar corretamente os Núcleos, determinando as relações que tenham com outras partes do modelo.
 
Amadureça o modelo. Encontre o Domínio Núcleo e forneça meios de facilmente distingui-lo da grande massa de apoio ao modelo e de código. Enfatize os conceitos mais valiosos e especializados. Faça com que o Núcleo seja pequeno.
 
Aplique o seu talento para o Domínio Núcleo, criando-o corretamente. Passe para o Núcleo o esforço de encontrar um modelo profundo e desenvolva um projeto suficientemente flexível para cumprir a visão do sistema. Justifique o investimento em qualquer outra parte que auxilie o núcleo destilado.
 
É importante atribuir os melhores desenvolvedores com a tarefa de implementação do Domínio Núcleo. Os desenvolvedores geralmente tendem a gostar de tecnologias, aprender uma linguagem melhor e mais recente, sendo conduzidos mais para a infraestrutura em vez da lógica de negócios. A lógica de negócios de um domínio parece ser chata para eles, de pouca recompensa. Afinal, qual o objetivo em aprender detalhes sobre trajetórias de avião? Quando o projeto termina, todo o conhecimento se torna uma coisa do passado, com muito pouco benefício. Mas a lógica de negócio do domínio é o coração do domínio. Erros na concepção e implementação do núcleo pode levar ao abandono de todo o projeto. Se o núcleo da lógica de negócios não faz o seu trabalho, os mais poderosos recursos tecnológicos não servirão para muita coisa.
 
Um Domínio Núcleo não é criado em uma etapa final. Existe um processo de refinamento e refatorações sucessivas que são necessários antes mesmo do surgimento mais claro do núcleo. Precisamos fazer do Núcleo uma peça central do projeto, especificando seus limites. Também precisamos repensar sobre os demais elementos do modelo no relacionamento com o novo Núcleo. Esses elementos também poderão ser refatorados e algumas funcionalidades tenderão a mudar.
 
Algumas partes do modelo adicionam complexidade sem capturar ou transmitir conhecimentos especializados. Qualquer coisa estranha faz com que o Domínio Núcleo seja mais difícil de discernir e compreender. O modelo enche as pessoas de princípios gerais que todos conhecem ou detalhes que pertençam às especialidades que não sejam o seu principal foco, mas que desempenham um papel de apoio. No entanto, esses outros elementos genérico são essenciais para o funcionamento do sistema e para expressão completa do modelo.
 
Identifique subdomínios coesos que não sejam os motivadores para seu projeto. Fatore modelos genéricos desses subdomínios e coloque-os em Módulos separados. Não deixe nenhum rastro de sua especialidade neles.
 
Depois de terem sido separados, minimize a prioridade no desenvolvimento continuado desses subdomínios em detrimento do Domínio Núcleo, evitando atribuir aos desenvolvedores principais outras tarefas (porque eles vão adquirir pouco conhecimento de domínio delas). Considere também soluções ‘de prateleira’ ou modelos publicados para esses Subdomínios Genéricos.
 
Todo domínio usa conceitos que são utilizados por outros domínios. Dinheiro e seus conceitos relacionados, como moeda e taxa de troca, podem ser incluídos em diferentes sistemas. Gráficos são outros conceitos amplamente utilizados, que é muito complexo por si só, mas que podem ser usados ​​em muitas aplicações.
 
Existem diferentes maneiras de implementar um Subdomínio Genérico:
 
1.    Solução de prateleira. Tem a vantagem de ter toda a solução já feita por outra pessoa. Há ainda uma curva de aprendizado associada a ela e essa solução introduz algumas dependências. Se o código for defeituoso, você precisa esperar pela correção. Também precisa usar compiladores e versões de bibliotecas corretos. A integração não é feita tão facilmente, em comparação com um sistema desenvolvido internamente.
2.    Terceirização. O projeto e a implementação são dados a outra equipe, provavelmente de outra empresa. Isso permite que você se concentre no Domínio Núcleo, tirando o fardo de lidar com outros domínios. Há ainda a inconveniência de integrar o código terceirizado. A interface usada para se integrar ao subdomínio necessita ser definida e comunicada à outra equipe.
3.    Modelo existente. Uma solução prática é a utilização de um modelo já criado. Há alguns livros que têm publicados padrões de análise, que podem ser usados ​​como inspiração para os nossos subdomínios. Pode não ser possível a cópia literal dos padrões, mas muitos deles podem ser usados com pequenas adequações.
4.    Implementação própria. Essa solução tem a vantagem de atingir o melhor nível de integração. Ele significa esforço extra, incluindo a carga de manutenção.

