# O que é Domain-Driven Design
 
O desenvolvimento de software é frequentemente aplicado na automatização de processos que já existam no mundo real, fornecendo soluções aos problemas reais de negócio. Esses processos e problemas são o domínio do software. Desde o princípio, devemos compreender que o software é originado e está profundamente relacionado a esse domínio.
 
O software é composto de código. Somos tentados a gastar grande parte do tempo com o código, visualizando o software como simplesmente objetos e métodos.
 
Considere a fabricação de um carro no passado. Os trabalhadores envolvidos na fabricação podem se especializar na produção das peças do carro, mas esses trabalhadores frequentemente têm uma visão limitada do processo completo de fabricação do automóvel. Ao final da fabricação, eles verão o carro como uma coleção enorme de peças que começaram a se encaixar, mas a fabricação do carro é muito mais complexa do que apenas simples encaixes. Um bom carro é originado a partir de uma visão. Continua com especificações bem elaboradas até que é iniciado o desenvolvimento do projeto. Meses, talvez anos, são gastos na melhoria e refinamento do projeto, até que ele reflita a visão original. O processo de design é realizado somente no papel. Boa parte deste processo envolve a construção e testes de modelos do carro em determinadas circunstâncias para verificar o seu funcionamento. O projeto pode ser modificado baseado nos resultados desses testes. Eventualmente, o carro será destinado à linha de montagem e as peças serão criadas e montadas em conjunto.
 
O desenvolvimento do software é similar. Nós não podemos apenas sentar e codificar, mesmo que sejamos especialistas em programação. Até poderíamos trabalhar dessa forma em casos triviais. Contudo software complexo não pode ser construído desta maneira.
 
A fim de criar um software bom, você tem de conhecer esse software como um todo. Não se pode criar um software de operação bancária sem ter uma compreensão clara do que é uma operação bancária como um todo. É seu dever compreender o domínio da operação bancária.
 
É possível criar um software complexo de operação bancária sem o pleno conhecimento do domínio? Nunca. Quem conhece de operação bancária? O arquiteto do software? Não. O analista do software? Não necessariamente. O analista sabe analisar um dado tópico, quando são fornecidos todos os ingredientes necessários. O desenvolvedor? Esquece. Quem então? Os banqueiros, obviamente. O sistema de operação bancária é bem compreendido pelos responsáveis e por seus especialistas. Eles sabem todos os detalhes. Este é o local onde deveremos sempre começar: o domínio.
 
Quando começamos um projeto de software, devemos focar no domínio que estamos operando. A finalidade principal do software é realçar um domínio específico. Fazendo isso, o software tem que se relacionar harmoniosamente com o domínio para o qual foi criado. Do contrário, introduzirá uma tensão no domínio, através de um mau funcionamento que provocará danos, até mesmo o caos.
 
Como poderemos fazer com que o software se relacione harmoniosamente com o domínio? A melhor maneira de fazer isso é fazendo com que o software reflita o domínio. O software precisa incorporar os conceitos e elementos-chave do domínio, relacionando-os precisamente. O software precisa modelar o domínio.
Alguém sem conhecimento da operação bancária deve aprender muito apenas lendo o código de um modelo de domínio. Isso é essencial. O software que não tem suas raízes plantadas profundamente no domínio não reagirá bem às mudanças com o passar do tempo.
Assim, começaremos com o domínio. E a partir daí? Um domínio é algo deste mundo. Não pode apenas ser feito sobre o teclado do computador para se transformar em código. Nós necessitamos criar uma abstração do domínio. Aprendemos muito sobre um domínio ao falar com os peritos do domínio. Mas esse conhecimento não será facilmente introduzido no código quando construímos o software, a menos que nós criemos uma abstração dele, uma visão em nossas mentes. No começo, essa visão sempre será incompleta. Mas com o tempo, trabalhando nela, faremos dela melhor, tornando-a cada vez mais clara. O que é essa abstração? É um modelo, um modelo do domínio. De acordo com Eric Evans, um modelo do domínio não é um diagrama particular; é a ideia passada pelo diagrama. Não é justo que o conhecimento fique apenas na cabeça de um perito do domínio; é uma forma seletiva de organização de conhecimento muito rigorosa. Um diagrama pode representar e comunicar o modelo, assim como um código bem escrito ou uma frase no Português.

O modelo é nossa representação interna do domínio e é estritamente necessário em todo o projeto e processo de desenvolvimento. Durante o processo do design, fazemos muitas referências ao modelo. O mundo em nossa volta é demasiadamente grande para nossas cabeças lidarem. Mesmo um domínio específico poderia ser mais do que a mente humana poderia lidar em um determinado momento. Precisamos organizar as informações, sistematiza-las, para dividi-las em partes menores, agrupando-as em módulos conceituais, obtendo cada módulo separadamente e lidando apenas com ele. Precisamos deixar algumas partes do domínio fora. Um domínio contém muita informação para inclui-lo por completo no modelo. E muito dele não é mesmo necessário para ser considerado. Este é o desafio. O que eu devo manter e o que eu devo jogar fora? Esta é a função do design, do processo de criação do software. O software de operação bancária certamente contém o endereço do cliente, mas não deve importar-se com a cor do olho do cliente. Este é um caso óbvio, mas outros exemplos não serão tão óbvios.
Um modelo é uma parte essencial do design do software. Nós necessitamos dele para tratar com a complexidade. Todo nosso processo de pensamento sobre o domínio é sintetizado dentro desse modelo. Isso é bom, mas esse conhecimento não pode ficar retido em nossas cabeças. Necessitamos comunicar esse modelo aos peritos do domínio, aos designers e aos desenvolvedores. O modelo é a essência do software, mas nós necessitamos criar maneiras de expressa-lo para comunica-lo a outra pessoa. Não estamos sozinhos nesse processo. Assim que necessitarmos compartilhar o conhecimento e a informação, precisaremos fazê-lo bem, de forma precisa e sem ambiguidade. Existem muitas maneiras diferentes de se fazer isso. Uma delas seria graficamente: diagramas, casos de uso, desenhos, figuras, etc. Outra é escrevendo. Escrevemos nossa visão do domínio. Outra forma é a linguagem. Podemos e devemos criar uma linguagem de comunicação sobre os detalhes do domínio. Abordaremos tudo isso mais tarde, mas o ponto principal é que nós necessitamos comunicar o modelo.
Quando temos um modelo expresso, podemos começar a fazer o projeto do código. Isso é diferente do projeto do software. Design do software é como criar a arquitetura de uma casa. De outro modo, o design do código está ligado aos detalhes, assim como a posição de uma pintura em uma determinada parede. O design do código é também muito importante, mas não mais importante que os fundamentos do design do software. Um erro do design do código geralmente é corrigido mais facilmente, os erros do design do software são muito mais caros de reparar. Uma coisa é mover a pintura para a esquerda, e outra coisa completamente diferente mover a casa de lugar. Mas no final, o produto não será bom se o design do código não for bom. Aqui os padrões de projeto do código deverão ser apresentados, e devem ser aplicados quando necessários. As boas técnicas de programação irão ajudar a criar um código limpo e de fácil manutenção.
Há diferentes abordagens para o design do software. Um é o modelo cascata, que envolve um número determinado de fases. Os peritos do negócio expõem as exigências mais importantes que são comunicadas aos analistas do negócio. Os analistas criam um modelo baseado nessas exigências e passam os resultados aos desenvolvedores, que começam a codificar baseado no que receberam. É um fluxo de sentido único do conhecimento. É uma abordagem tradicional no design do software que foi usada com um determinado nível de sucesso no passado, ainda que tivesse suas falhas e limitações. O problema principal é que não há nenhum retorno dos analistas aos peritos do negócio ou dos desenvolvedores aos analistas.

Outra abordagem são as metodologias ágeis, tais como a Extreme Programming (XP). Essas metodologias são movimentos coletivos contrários ao modelo cascata, sendo resultado das dificuldades de tentar expor os requisitos do projeto dentro da equipe, principalmente quando esses requisitos mudam. É realmente difícil criar um modelo completo que cubra todos os aspectos dos requisitos mais importantes do domínio. Isso exige muita pesquisa. Mesmo assim você simplesmente não conseguirá enxergar todos os problemas existentes no começo, nem poderá prever alguns dos efeitos colaterais ou pontos negativos de seu design. Outro problema que métodos ágeis tentam resolver é o tão conhecido "analysis paralysis", onde os membros da equipe ficam receosos em tomar algumas decisões sobre o projeto e nenhum avanço é percebido. Enquanto os defensores das metodologias ágeis reconhecem a importância das decisões de design, temem expor os requisitos errados. Preferem empregar um grande esforço na implementação com flexibilidade, no desenvolvimento iterativo, na participação dos stakeholders do negócio e nas várias refatorações contínuas. A equipe de desenvolvimento começa a aprender mais sobre o domínio do cliente e pode melhorar o produto de software, de modo que satisfaça as necessidades desses.
Os métodos ágeis têm seus próprios problemas e limitações; eles protegem a simplicidade, mas todos tem sua própria visão do que esta acontecendo. Veja bem, refatoração contínua feita pelos desenvolvedores sem princípios sólidos de design irá produzir códigos que são difíceis de compreender ou mudar. Por outro lado a abordagem cascata pode conduzir a uma reengenharia, cujo medo pode conduzir a outro: o de fazer um design completamente fora do escopo e refazer tudo novamente.
Este livro apresenta os princípios do Domain-Driven Design, que quando aplicado pode aumentar muito a habilidade dos processos de desenvolvimento para modelar e implementar os problemas complexos em um domínio reutilizável. O DDD combina as práticas de desenvolvimento e design, mostrando como o design e o desenvolvimento podem trabalhar juntos para criar uma melhor solução. Um bom design acelera o desenvolvimento e o feedback vindo do processo de desenvolvimento melhorará o design.

## Construindo o Conhecimento do Domínio
 
Vamos considerar o exemplo de um projeto para um sistema de controle de voo e como o conhecimento do domínio pode ser construído.
 
Milhares de aviões estão no ar sobrevoando todo o planeta. Estão voando em seus próprios trajetos para seus devidos destinos. É muito importante certificar-se de que não colidirão no ar. Não tentaremos elaborar um sistema inteiro de controle do tráfego, mas um subconjunto menor que seja um sistema de monitoração do voo. O projeto proposto é um sistema de monitoramento de rotas de cada voo sobre alguma área, determinando se o voo esta seguindo sua suposta rota ou não, e se existe a possibilidade de uma colisão.
Quando será que iremos começar a ter uma perspectiva de desenvolvimento do software? Na seção anterior dissemos que devemos começar por compreender o domínio, que nesse caso, é o monitoramento do tráfego aéreo. Controladores de tráfego aéreo são os especialistas desta área. Mas os controladores não são projetistas do sistema ou especialistas do software. Não espere que eles elaborem uma descrição completa do domínio de seu problema.
Os controladores de tráfego aéreo possuem um vasto conhecimento sobre seu domínio, mas para construir um modelo será necessário extrair as informações essenciais e centralizá-la. Quando você começar a falar com eles, ouvirá muito sobre os aviões que decolam, aterrissam, os perigo de colisão, os aviões que estão esperando a autorização de pouso etc. Para encontrar ordem nesta aparente quantidade caótica de informação, teremos que começar por algum lugar.
O controlador e você concordam que cada avião tem uma partida e um aeroporto de destino. Sendo assim nós temos um avião, uma partida e um destino, como mostrado na figura abaixo:

// TODO: colocar a imagem aqui
 
Enfim, o avião sai de algum lugar e chega a outro. Mas o que acontece no ar? Qual o trajeto do voo? Realmente estamos mais interessados no que acontece durante o voo. O controlador diz que será atribuído ao avião um plano do voo que supostamente deve descrever toda sua trajetória. Enquanto você aguardava sobre a definição de um plano de voo, imaginou qual o caminho seguido pelo avião enquanto ele esta no ar.
 
Após uma discussão mais aprofundada, você ouve uma palavra interessante: rota. Ela instantaneamente captura sua atenção por uma boa razão: ela contém um conceito importante sobre a trajetória do avião. O que os aviões fazem durante o voo? Eles seguem uma rota. Obviamente o ponto de partida e de destino do avião são também os pontos que começam e terminam a rota. Assim, em vez de associar a aeronave a pontos de partida e destino, parece mais natural associá-la a uma rota, que por sua vez se associa com a partida e o destino correspondentes.

Falando com o controlador sobre as rotas que os aviões seguirão, você descobriu que a rota é realmente composta por pequenos segmentos, que juntos constituem uma espécie de uma linha imaginária desde a partida ao seu destino. A linha supostamente passa por pontos fixos pré-determinados. Assim, uma rota pode ser considerada uma série de pontos consecutivos. Neste momento você já não vê a partida e o destino como pontos terminais da rota, mas apenas outros dois pontos entre outros existentes. Isso provavelmente é completamente diferente de como o controlador os vê, mas é uma abstração necessária para ajudar mais tarde. As mudanças resultantes baseadas nestas descobertas são:

O diagrama mostra outro elemento: o fato de que cada ponto é uma localização fixa a ser seguida pela rota no mapa, expresso tridimensionalmente. Mas quando você falar ao controlador descobrirá que ele não vê dessa maneira. Realmente vê a rota como a projeção na terra do plano de voo. Os pontos são fixos na superfície do trajeto, determinado excepcionalmente por suas latitude e longitude. Assim o diagrama correto é:

O que está acontecendo realmente aqui? Você e os peritos do domínio estão falando, vocês estão trocando conhecimentos. Você começa a fazer perguntas e eles respondem. Enquanto fazem isso, os conceitos essenciais do domínio do tráfego aéreo estão sendo definidos. Esses conceitos podem sair desorganizados, mas ainda assim são essenciais para compreender o domínio. Você e os peritos do domínio precisam aprender o máximo possível sobre o domínio do controle de tráfego aéreo. E fazendo as perguntas certas, processando a informação de maneira correta, você e os peritos começarão a esboçar uma visão do domínio, um modelo do domínio. Essa visão é incompleta e não revisada, mas é o começo de que você precisa. Tente entender os conceitos essenciais ao domínio.

Essa é uma parte importante do design. Geralmente há discussões longas entre arquitetos do software ou desenvolvedores e os peritos do domínio. Os especialistas do software querem extrair o conhecimento dos peritos do domínio e também têm que transformá-lo em algo útil. Em dado momento, eles desejarão criar um primeiro protótipo para ver como o sistema funcionará. Ao fazê-lo, poderemos encontrar algumas questões referentes aos seus modelos, ou à sua abordagem, que podem nos levar a querer mudar o modelo. A comunicação não deve ser feita somente em único sentido, dos peritos do domínio para os arquitetos do software e ainda mais para os desenvolvedores. Deve haver um retorno de informação que ajude a criar um modelo melhor, tornando mais clara a compreensão do domínio. Os peritos do domínio conhecem sua área de perícia, mas organizam/usam o conhecimento de uma maneira específica, que não é sempre a melhor a ser executada em um software. A mente analítica dos designers e desenvolvedores do software contribui para alguns dos conceitos chaves como "Aircraft Route * Fix 2DPoint" do domínio, durante as discussões com os peritos do domínio, ajudando também a construir uma estrutura para as discussões futuras como veremos no capítulo seguinte. Nós, especialistas do software (arquitetos do software e os desenvolvedores) e os peritos do domínio, estamos criando o modelo do domínio juntos, e o modelo é o lugar onde essas duas áreas de competência convergirão. Aparenta ser um processo muito moroso, e é, mas é como deve ser, porque a finalidade maior do software é resolver problemas de negócio em um domínio real da vida, por isso, a informação do domínio do software tem que estar sincronizada ao domínio real.
