# Model-Driven Design
 
Os capítulos anteriores salientaram a importância de uma aproximação do desenvolvimento do software centrado no domínio do negócio. Dissemos que é de fundamental importância criar um modelo que esteja profundamente enraizado no domínio, refletindo os conceitos essenciais do domínio com grande precisão. 

A Linguagem Ubíqua deve ser plenamente exercida durante todo o processo, a fim de facilitar a comunicação entre os especialistas do software e os peritos do domínio, para descobrir os conceitos chaves do domínio que devam ser usados no modelo. A finalidade desse processo é criar um modelo bom. A etapa seguinte é implementar o modelo no código. Esse processo é igualmente importante para o desenvolvimento do software. Ter criado um grande modelo, mas não transferi-lo corretamente para o código acabará criando software de qualidade questionável.

Acontece que os analistas do software trabalham com os peritos do domínio do negócio durante meses, descobrem os elementos fundamentais do domínio, enfatizam os relacionamentos entre eles, criam um modelo correto, que capta com precisão o domínio. Então, o modelo é transferido para os desenvolvedores de software. Os desenvolvedores olham o modelo e descobrem que alguns dos conceitos ou dos relacionamentos encontrados neles não podem corretamente ser expressos no código. Assim, usam o modelo como a fonte original da inspiração, mas eles criam seu próprio design contendo apenas algumas ideias do modelo e adicionam algumas ideias próprias. O processo de desenvolvimento continua e mais classes são adicionadas ao código, expandindo a divisão entre o modelo original e a implementação definitiva. Não temos garantia de resultados satisfatórios. Bons desenvolvedores podem até entregar um produto que funcione, mas será que ele vai resistir ao tempo? Será que ele vai ser facilmente estendido? Será que ele é fácil de dar manutenção?

Qualquer domínio pode ser expresso com muitos modelos, e qualquer modelo pode ser expresso de várias maneiras no código. Para cada problema particular pode haver mais de uma solução. Qual escolha fazer? Ter um modelo analiticamente correto não significa que o modelo pode ser expresso diretamente no código. Talvez a sua execução quebre alguns princípios do design do software, o que não é aconselhável. É importante escolher um modelo que possa ser facilmente e exatamente extraído para o código. Como fazer a abordagem e a transição do modelo para o código?

Uma das técnicas de design recomendadas é chamada de modelo de análise, que é separada do design do código e geralmente é usada por pessoas diferentes. O modelo de análise é o resultado da análise do domínio do negócio, resultando em um modelo que não leva em conta o software a ser implementado. Tal modelo é usado para compreender o domínio. Um determinado nível de conhecimento é construído e o resultado do modelo pode estar analiticamente correto. O software não é levado em consideração nessa fase, uma vez que seja considerado um fator a mais para confusão. Esse modelo afetará os desenvolvedores, que estarão incumbidos de compreender e fazer o design. Uma vez que o modelo não foi construído com princípios de design em mente, ele provavelmente não servirá muito bem a essa finalidade. Os desenvolvedores terão que adaptá-lo ou criar um design separado. E não é fácil fazer essa adaptação entre o design e o código. O resultado é que os modelos de análise são abandonados logo depois que a codificação começa.
 
Uma das principais questões com essa abordagem é que os analistas não podem prever alguns dos defeitos em seu modelo e todas as complexidades do domínio. Os analistas podem ter adentrado em detalhes em alguns componentes do modelo e não detalharam bastante outros. Os detalhes mais importantes são descobertos durante o processo de design e de execução. Um modelo que seja indigno ao domínio poderá vir a ter problemas sérios com os objetos de persistência ou de desempenho inaceitável.
Os desenvolvedores serão obrigados a tomar as próprias decisões, mudando o design a fim resolver um problema real que não foi considerado quando o modelo foi criado. Eles criam um design afastado do modelo, tornando-o menos relevante.

Se os analistas trabalharem independentemente, criarão, eventualmente, um modelo. Quando esse modelo for passado aos designers, alguns dos conhecimentos dos analistas sobre o domínio e o modelo serão perdidos. Mesmo que o modelo possa ser expresso em diagramas e na escrita, ainda há chances de os designers não compreenderem o seu significado, o relacionamento entre seus objetos e seus comportamentos. Existem detalhes do modelo que não são expressos facilmente em um diagrama e não podem inteiramente ser apresentados sequer por escrito. Os desenvolvedores passarão por momentos complicados para esboçar isso. Em alguns casos, farão algumas suposições sobre o comportamento pretendido, possivelmente errando, o que resultará em um funcionamento incorreto do programa.
Os analistas têm suas próprias reuniões fechadas onde muitas coisas são discutidas sobre o domínio e há um grande compartilhamento do conhecimento. Eles criam um modelo que supostamente contém toda a informação necessária, de uma forma condensada. Os desenvolvedores têm que assimilar tudo, lendo os documentos originais que lhes foram passados. Seria muito mais produtivo se os desenvolvedores pudessem se juntar às reuniões dos analistas e assim alcançar uma visão desobstruída e completa do domínio e do modelo antes de começarem projetar o código.

Uma melhor abordagem é estreitar a relação entre modelagem de domínio e design. O modelo deve ser construído com um olho aberto às considerações do software e o outro no design. Os desenvolvedores devem ser incluídos no processo de modelagem. A ideia principal é escolher um modelo que possa apropriadamente ser expresso no software, de modo que o processo do design seja direto e baseado no modelo. Firmemente relacionar o código a um modelo subjacente dá significação ao código e torna o modelo relevante.

Envolver os desenvolvedores é importante, pois dá a certeza de que o modelo pode ser implementado no software. Se existe algo de errado, é identificado e o problema pode facilmente ser corrigido.
Aqueles que escrevem o código devem conhecer o modelo muito bem e devem se sentir responsáveis pela sua integridade, compreendendo que a alteração do código implicará numa mudança do modelo. Entretanto, eles irão refatorar o código ao ponto de não expressar mais o modelo original. Se o analista for separado do processo de implementação, logo perderá o discernimento sobre as limitações introduzidas pelos desenvolvedores. O resultado é um modelo que não seja prático.
Toda pessoa técnica que contribui para o modelo deve gastar algum tempo analisando o código, qualquer que seja o papel primordial que ele ou ela desempenhe no projeto. Alguém responsável por mudar o código deve aprender a expressar o modelo através do código. Cada desenvolvedor deve estar envolvido em algum nível da discussão sobre o modelo e ter o contato com peritos do domínio. Aqueles que contribuem de maneiras diferentes devem, conscientemente, engajar aqueles que fazem o código, em uma troca dinâmica de ideias do modelo através da Linguagem Ubíqua.

Se o design ou alguma parte central dele não estiverem relacionados ao modelo do domínio, ele será de pouco valor e a exatidão do software será suspeita. Ao mesmo tempo, complexos mapeamentos entre modelos e funções do design são difíceis de compreender e, na prática, impossíveis de serem mantidos com as mudanças no design. O ideal é dividir a análise e o design de modo que a perspicácia adquirida em cada uma dessas atividades não prejudique ambas.

Projete uma parcela do sistema de software de forma que reflita o modelo do domínio de uma maneira direta, para que a transição seja óbvia. Revise o modelo e modifique-o para ser implementado mais naturalmente no software, mesmo quando você procura abstrair uma introspecção mais profunda do domínio. Procure um único modelo que sirva a essas finalidades, apoiando sempre uma fluência na Linguagem Ubíqua.
Extraia do modelo a terminologia utilizada no design e a atribuição básica de responsabilidades. O código se tornará uma expressão do modelo, de modo que a modificação no código possa ser uma mudança do modelo. O seu efeito deve refletir corretamente nas demais atividades do projeto.

Acoplar firmemente a implementação a um modelo geralmente requer ferramentas de desenvolvimento de software e linguagens de programação que suportem um paradigma de modelagem, tal qual a programação orientada a objeto.

A programação orientada a objeto é apropriada para o modelo de implementação porque ambos são baseados no mesmo paradigma. A programação orientada a objetos fornece classes dos objetos e associações dessas classes, das instâncias do objeto e a relação entre eles. As linguagens OOP fazem o possível para criar mapeamentos diretos entre os objetos do modelo e seus relacionamentos com suas contrapartes na programação.
 
Linguagens procedurais oferecem suporte limitado para model-driven design. Tais linguagens não oferecem as construções necessárias para implementar os principais componentes de um modelo. Alguns dizem que OOP pode ser feita com uma linguagem procedural como C, e de fato, algumas das funcionalidades podem ser reproduzidas assim. Os objetos podem ser simulados como estruturas de dados. Tais estruturas não contêm o comportamento do objeto e isso tem que ser adicionado separadamente através de funções. O significado desses dados existe apenas na mente do desenvolvedor, pois o código em si não é autoexplicativo. Um programa escrito em uma linguagem procedural geralmente é descrito como um conjunto de funções, uma chamando a outra, trabalhando juntas para alcançar determinado resultado. Tal programa não pode facilmente encapsular conexões conceituais, fazendo com que o mapeamento entre domínio e código seja difícil de ser conseguido.
 
Alguns domínios específicos, como a matemática, podem ser facilmente modelados e implementados usando a programação procedural, pois muitas teorias matemáticas, por serem essencialmente cálculos, são abordadas simplesmente utilizando-se chamadas a funções e estruturas de dados. Os domínios mais complexos não são apenas um conjunto de conceitos abstratos envolvendo cálculos e não podem ser reduzidos a um conjunto de algoritmos, de modo que as linguagens procedurais ficam aquém da tarefa de expressar os respectivos modelos. Por essa razão, não é recomendável usar a programação procedural para o model-driven design.

# Os Blocos de Construção de um Model-Driven Design
 
As seguintes seções deste capítulo apresentarão os mais importantes padrões a serem usados no DDD. A finalidade desses padrões é apresentar alguns dos elementos chaves de modelagem de objetos e design de software do ponto de vista do DDD. O seguinte diagrama é um mapa dos padrões apresentados e do relacionamento entre eles.

## Arquitetura em Camadas
 
Quando criamos uma aplicação de software, uma grande parte da aplicação não está relacionada diretamente ao domínio, mas faz parte da infraestrutura ou serve ao próprio software. É possível que a parte referente ao domínio de uma aplicação seja bem pequena comparada ao restante, já que normalmente um software típico contém muito código relacionado ao acesso ao banco de dados, arquivos, acesso à rede, interfaces com o usuário etc.

Em um programa orientado a objeto, interface com usuário, base de dados e outros códigos utilitários são frequentemente desenvolvidos diretamente nos objetos de negócio. Lógicas de negócio adicionais são encaixadas no comportamento das telas de interface e nos scripts de banco de dados. Isso às vezes acontece porque é a maneira mais fácil e rápida de fazer o sistema funcionar.
Entretanto, quando o código relacionado ao domínio é misturado com outras camadas, torna-se extremamente difícil de entender e manter. Mudanças superficiais na interface podem realmente mudar a lógica do negócio. Mudar uma regra de negócio pode requerer o rastreamento na interface com o usuário, no script da base de dados ou em outros elementos do programa. Implementar um código DDD coerente se tornará impraticável. Os testes automatizados se tornam estranhos. Com todas as tecnologias e lógicas envolvidas em cada atividade, o programa deve se manter muito simples, senão será impossível de entendê-lo.

Assim, divida um programa complexo em CAMADAS. Desenvolva uma concepção dentro de cada camada que seja coerente e que dependa apenas das camadas inferiores. Siga padrões arquiteturais que forneçam baixo acoplamento com as camadas superiores. Concentre todo o código relacionado ao modelo do domínio em uma única camada, isolando-a da interface com o usuário, da aplicação e do código da infraestrutura. Objetos de domínio, livres da responsabilidade de se mostrarem, de se armazenarem e de administrarem tarefas de aplicativos e assim por diante, podem focar na expressão do modelo de domínio. Isso permite ao modelo se tornar rico e claro o bastante para capturar a essência do conhecimento do negócio, funcionando da forma como deve ser.
A solução para uma arquitetura comum no DDD contém quatro camadas essenciais:
 
Interface com o Usuário (Presentation Layer): Responsável por apresentar a informação ao usuário e interpretar os seus comandos
Camada de Aplicação (Application Layer): Essa é uma fina camada que coordena a atividade da aplicação. Não contém a lógica de negócio. Não armazena o estado dos objetos de negócio, mas pode armazenar o estado do progresso de uma tarefa da aplicação.
Camada de Domínio (Domain Layer): Essa camada contém a informação sobre o domínio, sendo o coração do negócio do software. O estado dos objetos de negócio se localiza aqui. A persistência dos objetos de negócio e possivelmente seu estado são delegados à camada da infraestrutura.
Camada de Infraestrutura (Infrastructure Layer): Age como uma biblioteca de suporte para todas as outras camadas. Ela fornece uma comunicação entre as camadas, adiciona persistência a objetos de negócio, contém bibliotecas utilitárias para a camada de interação com o usuário etc.
É importante dividir uma aplicação em camadas separadas e estabelecer regras de interações entre elas. Se o código não for separado claramente em camadas, ficará muito difícil de controlar as mudanças. Uma simples mudança em uma seção do código pode gerar resultados inesperados e indesejáveis em outras partes. A camada de domínio deve ser focada no núcleo das tarefas do domínio. Não deve se envolver em atividades da infraestrutura. A interface com o usuário não deve ser acoplada à lógica de negócio e nem às tarefas que pertençam normalmente à camada de infraestrutura. A camada de aplicação é necessária em muitos casos onde tem de haver um gerenciamento sobre a lógica de negócio, supervisionando e coordenando a atividade total da aplicação.
Um exemplo típico de interação entre as camadas de aplicação, domínio e infraestrutura poderia ser dessa forma: o usuário deseja registrar rotas de voos e pergunta ao serviço da aplicação na camada de aplicação como fazer isso. A camada de aplicação busca os objetos de domínio relevantes através da camada de infraestrutura e invoca métodos específicos para fazer essa atividade, por exemplo, para verificar as margens de segurança de outros voos já registrados. Uma vez que os objetos do domínio fizeram todas as verificações e atualizaram seu status para “decidido”, o serviço da aplicação persiste os objetos através da infraestrutura.

## Entidades
 
Existe uma categoria de objetos que parecem ter uma identidade, que permanece a mesma em todos os estados do software. Para esses objetos, não são os atributos que importam, mas uma linha de continuidade e identidade, que abrange a vida de um sistema e pode se estender para além dele. Tais objetos são chamados de Entidades.
 
Linguagens OOP mantêm instâncias de objetos na memória e elas associam uma referência ou um endereço de memória para cada objeto. Esta referência é única para cada objeto em um determinado momento de tempo, mas não há garantia de que ele vai ficar assim por período de tempo indeterminado. Na verdade, o contrário é verdadeiro. Os objetos são constantemente alocados e deslocados na memória, são serializados e enviados através da rede, são recriados no outro extremo ou são destruídos. Essa referência, que permanece como uma identidade no ambiente de execução do programa não é a identidade que estamos falando. Se há uma classe que retém informações do tempo, como temperatura, é perfeitamente possível ter duas instâncias distintas da respectiva classe, ambos contendo o mesmo valor. Os objetos são perfeitamente iguais e intercambiáveis um com o outro, mas têm referências diferentes. Eles não são entidades.
 
Se fôssemos implementar o conceito de uma pessoa usando um programa de software, provavelmente iríamos criar uma classe Pessoa com uma série de atributos: nome, data de nascimento, local de nascimento etc. Qualquer um desses atributos é a identidade da pessoa? Nome não pode ser a identidade porque pode haver mais pessoas com o mesmo nome. Não poderíamos distinguir pessoas com o mesmo nome, caso levássemos em conta apenas esse atributo. Também não poderíamos usar a data de nascimento, pois há muitas pessoas nascidas no mesmo dia. O mesmo se aplica para o lugar de nascimento. Um objeto deve ser distinguido de outros, embora eles possam ter os mesmos atributos. Identidade equivocada pode levar à corrupção de dados.
 
Considere um sistema de contas bancárias. Cada conta tem seu próprio número. Uma conta pode ser precisamente identificada pelo seu número. Esse número permanece inalterado por toda a vida do sistema e assegura continuidade. O número da conta pode existir como um objeto na memória, ser destruído na memória e enviado para o banco de dados. Também pode ser arquivado quando a conta é fechada, mas ainda existe em algum lugar, desde que haja algum interesse em mantê-lo por perto. Não importa que representação ele tenha, o número permanece sempre o mesmo.
 
Portanto, implementar entidades em software significa criar identidade. Para uma pessoa, pode ser uma combinação de atributos: nome, data de nascimento, local de nascimento, nome dos pais, o endereço atual etc. O número de Seguridade Social também é usado nos EUA para criar identidade. Para uma conta bancária, o número da conta parece ser suficiente para a sua identidade. Normalmente, a identidade pode ser um atributo do objeto, uma combinação de atributos, um atributo especialmente criado para preservar e expressar a identidade ou até mesmo um comportamento. É importante para dois objetos com diferentes identidades serem facilmente distinguidos pelo sistema e dois objetos com a mesma identidade serem considerados o mesmo pelo sistema. Se essa condição não for cumprida, então todo o sistema pode se tornar corrompido.
 
Há maneiras diferentes para criar uma identidade única para cada objeto. O ID pode ser gerado automaticamente por um módulo e usado internamente no software sem torná-lo visível para os usuários. Pode ser uma chave primária em uma tabela do banco de dados, que é única no banco de dados. Sempre que o objeto é recuperado do banco de dados, a sua ID é recuperado e recriado em memória. O ID pode ser criado pelo usuário como acontece com os códigos associados aos aeroportos. Cada aeroporto tem um ID exclusivo, que é internacionalmente reconhecido e utilizado pelas agências de viagem em todo o mundo para identificar os aeroportos em suas agendas de viagens. Outra solução é usar os atributos do objeto para criar o ID, e quando isso não for suficiente, outro atributo pode ser adicionadas para ajudar a identifica-lo.
 
Quando um objeto se distinguir pela sua identidade, em vez de seus atributos, faça disso primordial para a sua definição no modelo. Mantenha a definição de classe simples e focada na continuidade do ciclo de vida, na identidade. Defina uma maneira de distinguir cada objeto independentemente da sua forma ou história. Esteja atento aos requisitos que demandem a similaridade de objetos por atributos. Defina uma operação que garanta produzir um resultado único para cada objeto, possivelmente anexando um símbolo que é conhecido ser único. Esse meio de identificação pode vir de fora ou pode ser um identificador arbitrário criado por e para o sistema, mas deve corresponder às distinções de identidade no modelo. O modelo deve definir o que significa ser a mesma coisa.
 
As Entidades são objetos importantes de um modelo de domínio, devendo ser consideradas desde o início do processo de modelagem. Também é importante determinar se um objeto precisa ser uma entidade ou não, algo que discutiremos no próximo tópico.
 
 
## Objetos de Valor
 
Discutimos sobre as entidades e a importância de reconhecê-las durante o início da fase de modelagem. Entidades são objetos necessários em um modelo de domínio. Devemos transformar todos os objetos em entidades? Cada objeto deve ter uma identidade?
 
Podemos ser tentados a transformar todos os objetos em entidades. Entidades podem ser rastreadas. Mas rastrear e criar identidade tem um custo. Precisamos ter certeza de que cada instância tem identidade única, pois o acompanhamento da identidade não é muito simples. É preciso de um pensamento muito cuidadoso para decidir o que é necessário para uma identidade existir, pois um erro de decisão levaria a objetos com a mesma identidade, algo que não é desejado. Há também implicações no desempenho do sistema ao transformar todos os objetos em entidades. Tem que haver uma instância para cada objeto. Se Cliente é um objeto de entidade, portanto uma instância desse objeto que representa um cliente de banco específico, não pode ser reutilizado para operações de conta correspondentes a outros clientes. O resultado é que tal instância tem que ser criada para cada cliente. Isso pode resultar na degradação do desempenho do sistema ao lidar com milhares de instâncias.
 
Vamos considerar um aplicativo de desenho. O usuário é apresentado a uma tela e ele pode desenhar pontos e linhas de qualquer espessura, estilo e cor. É útil criar uma classe de objeto chamado Ponto. O programa pode criar uma instância desta classe para cada ponto na tela. Tal ponto poderia conter dois atributos associados às coordenadas de tela. É necessário considerar que cada ponto tenha uma identidade? Será que haverá continuidade? Parece que a única coisa que importa para tal objeto são suas coordenadas.
 
Há casos em que precisaremos manter alguns atributos de um elemento do domínio. Não estamos interessados ​​que objeto ele seja, mas nos atributos que ele possua. Um objeto que é usado para descrever certos aspectos de um domínio, e que não tem identidade, é definido como Objeto de Valor.
 
É necessário distinguir entre Objetos de Entidade e de Valor. Não é útil fazer todos os objetos virarem entidades por causa da uniformidade. Na verdade, é recomendável escolher como entidades apenas os objetos que satisfaçam à definição da entidade. Faça do resto Objetos de Valor. (Vamos apresentar outro tipo de objeto na próxima seção, mas vamos supor que temos apenas objetos entidade e objetos de valor, por enquanto). Isso simplificará o projeto, trazendo algumas outras consequências positivas.
 
Não tendo identidade, os Objetos de Valor podem ser facilmente criados e descartados. Ninguém se preocupará com a criação de uma identidade e o coletor de lixo tomará conta do objeto quando não for mais referenciado por qualquer outro objeto. Isso simplifica muito o design.
 
É altamente recomendável que os objetos de valor sejam imutáveis. Eles são criados com um construtor e nunca modificados durante o tempo de vida. Quando você quiser um valor diferente para o objeto, você simplesmente cria outro. Isso tem consequências importantes para o design. Por serem imutáveis e não terem identidade, Objetos de Valor podem ser compartilhados. Isso pode ser imprescindível em alguns projetos. Objetos imutáveis ​​são compartilháveis, ​​com implicações importantes no desempenho. Eles também manifestam integridade, ou seja, a integridade dos dados. Imagine o que significaria compartilhar um objeto que não é imutável. Um sistema aéreo de reserva de viagens pode criar objetos para cada voo. Um dos atributos poderia ser o código de voo. Um cliente registra um voo para um determinado destino. Outro cliente quer reservar o mesmo voo. O sistema escolhe a reutilização do objeto que contém o código de voo, porque é quase o mesmo voo. Nesse meio tempo o cliente muda de ideia e escolhe pegar um voo diferente. O sistema altera o código de voo porque este não é imutável. O resultado é que o código do voo do primeiro cliente mudou também.
 
Uma regra de ouro é: se os objetos de valor são compartilháveis, eles devem ser imutáveis. Objetos de Valor devem ser mantidos finos e simples. Quando um objeto de valor é necessário para outra parte, pode ser simplesmente passados ​​por valor, ou uma cópia do mesmo pode ser criada e dada. Fazer uma cópia de um objeto de valor é simples e, normalmente, sem quaisquer consequências. Se não há identidade, você pode fazer quantas cópias quiser, destruindo todas elas quando necessário.
 
Objetos de Valor podem conter outros Objetos de Valor, e eles podem até mesmo conter referências a Entidades. Embora os Objetos de Valor sejam usados apenas para manter atributos de um objeto de domínio, isso não significa que ele deva conter uma lista longa com todos os atributos. Atributos podem ser agrupados em diferentes objetos. Atributos escolhidos para se tornarem um objeto de valor devem formar um todo conceitual. Um cliente está associado a um nome, uma rua, uma cidade e um estado. É melhor que as informações de endereço fiquem em um objeto separado e o objeto cliente irá incluir uma referência a tal objeto. Rua, cidade e estado devem estar em um objeto próprio, o Endereço, porque pertencem a um único conceito, ao invés de estar separados nos atributos do cliente, como mostrado no diagrama abaixo.


## Serviços
 
Quando analisarmos o domínio e tentarmos definir os principais objetos que compõem o modelo, descobriremos que alguns aspectos do domínio não serão facilmente mapeados para objetos. Objetos são geralmente considerados como possuidores de atributos, um estado interno que é gerenciado por ele e exibem um comportamento. Quando desenvolvemos a Linguagem Ubíqua, os principais conceitos do domínio são introduzidos na linguagem e os seus substantivos são facilmente mapeados para objetos. Os verbos da linguagem, associados aos seus substantivos correspondentes, tornam-se parte do comportamento desses objetos. Mas existem algumas ações no domínio, alguns verbos, que não aparentam pertencer a qualquer objeto. Eles representam um comportamento importante do domínio, não podendo ser negligenciados ou simplesmente incorporados a algumas das Entidades ou Objetos de Valor. Adicionando tal comportamento a um objeto iria estragá-lo, com uma funcionalidade que não pertence a ele. No entanto, usando uma linguagem orientada a objetos, teremos que usar um objeto para esta finalidade. Não podemos apenas ter uma função separada por conta própria. Ela tem que estar ligada a algum objeto. Muitas vezes esse tipo de comportamento atravessa vários objetos, talvez de diferentes classes. Por exemplo, para transferir o dinheiro de uma conta para outra, a função deveria estar na conta de envio ou na conta de recebimento? Veja que a função ficará deslocada em ambos.
 
Quando tal comportamento for reconhecido no domínio, a melhor prática será declará-lo como um Serviço. Tal objeto não tem um estado interno e seu propósito é simplesmente fornecer funcionalidade para o domínio. A assistência prestada por um Serviço pode ser uma das mais importantes, podendo agrupar funcionalidades correlatas que sirvam às Entidades e aos Objetos de Valor. É muito melhor declarar explicitamente o serviço, porque cria uma clara distinção no domínio, que encapsula um conceito. Cria-se confusão tentar incorporar essa funcionalidade em uma Entidade ou Objetos de Valor, pois não ficará claro o que esses objetos representam.
 
Serviços funcionam como interfaces que fornecem operações. Serviços são comuns em frameworks técnicos, mas eles podem ser usados ​​na camada de domínio também. Um serviço não se trata de um objeto realizando o serviço, mas sim as operações sendo realizadas em / para um objeto. Desta forma, um serviço geralmente se torna um ponto de conexão para muitos objetos. Esta é uma das razões pelas quais o comportamento que naturalmente pertence a um serviço não deve ser incluído em objetos de domínio. Se essa funcionalidade está incluída nos objetos de domínio, uma densa rede de associações é criada entre eles e os objetos que são os beneficiários das operações. Um elevado grau de acoplamento entre muitos objetos é um sinal de uma concepção ruim, porque torna o código difícil de ler e compreender e, mais importante, torna-o difícil de mudar.
 
Um Serviço não deve substituir a operação que normalmente pertence a objetos de domínio. Não devemos criar um serviço para cada operação necessária. Mas, quando tal operação se destaca como um conceito importante no domínio, o serviço deve ser criado para ela. Existem três características de um Serviço:
 
A operação realizada pelo Serviço refere-se a um conceito do domínio que não pertence naturalmente a uma Entidade ou Objeto de Valor.
A operação realizada refere-se a outros objetos no domínio.
A operação é stateless (não guarda estado).
 
Quando um processo significativo ou transformação no domínio não forem uma responsabilidade natural de um Objeto de Valor ou Entidade, adicione a operação ao modelo como uma interface independente declarada como um Serviço. Defina a interface em termos da linguagem do modelo e certifique-se de que o nome da operação faz parte da Linguagem Ubíqua. Torne os Serviços stateless.
 
Ao usar Serviços, é importante manter a camada de domínio isolada. Facilmente fica-se confuso entre os serviços que pertençam à camada de domínio e aqueles pertencentes à infraestrutura. Também pode haver serviços na camada de aplicação que agreguem um nível maior de complexidade. Esses serviços são ainda mais difíceis de separar de suas contrapartes que residam na camada de domínio. Enquanto estivermos trabalhando no modelo e durante a fase de design, precisamos ter certeza de que o nível do domínio permanece isolado dos demais níveis.
 
Ambos os Serviços de aplicação e domínio são geralmente construídos em cima de Entidades de domínio e Objetos de Valor, proporcionando funcionalidades necessárias diretamente relacionadas a esses objetos. Decidir a camada a que um serviço pertencerá é difícil. Se a operação realizada conceitualmente pertence à camada de aplicação, então o serviço deverá ser colocado lá. Se a operação envolver objetos de domínio, sendo estritamente relacionada com o domínio, atendendo a uma necessidade do domínio, então deverá pertencer nessa camada.
 
Vamos considerar um exemplo prático: um aplicativo de relatórios web. Os relatórios fazem uso de dados armazenados em um banco de dados, sendo eles gerados com base em modelos. O resultado final é uma página HTML que é mostrada para o usuário em um navegador da web.
 
A camada de interface do usuário é formada por páginas web que permitem ao usuário se logar, selecionar o relatório desejado e clicar em um botão para gerar o relatório. A camada de aplicação é uma fina camada que fica entre a interface com o usuário, o domínio e a infraestrutura. Ela interage com a infraestrutura de banco de dados durante operações de login e interage com a camada de domínio quando ele precisa criar relatórios. A camada de domínio irá conter o núcleo do domínio, ou seja, os objetos diretamente relacionados com os relatórios. Dois desses objetos são o Relatório e o Modelo, nos quais os relatórios são baseados. A camada de infraestrutura irá apoiar o acesso ao banco de dados e aos arquivos.
 
Quando um usuário seleciona um relatório a ser criado, ele na verdade seleciona o nome do relatório a partir de uma lista de nomes. Esse é o reportID, uma String. Alguns outros parâmetros são passados, como os itens mostrados no relatório e o intervalo de tempo dos dados incluídos no relatório. Mas vamos mencionar apenas os reportID pela simplicidade. Esse nome é passado através da camada de aplicação para a camada de domínio. A camada de domínio é responsável pela criação e retorno do relatório, dado o seu nome. Como os relatórios são baseados em modelos, um serviço poderia ser criado objetivando obter o modelo que corresponde a um reportID. Esse modelo é armazenado em um arquivo ou no banco de dados. Não é apropriado colocar tal operação no objeto Relatório em si. Não pertence também ao objeto Modelo. Então, criamos um Serviço separado cujo objetivo é recuperar um modelo de relatório com base no ID do relatório. Esse seria um serviço localizado na camada de domínio. Poderia fazer uso da infraestrutura de arquivo para recuperar o modelo do disco.


## Módulos
 
Para um aplicativo grande e complexo, o modelo tende a se tornar cada vez maior. O modelo chega a um ponto onde é difícil de tratar como um todo, não se compreendendo as relações e interações entre as suas diferentes partes. Por esse motivo, é necessário organizar o modelo em módulos. Módulos são usados ​​como um método de organização de conceitos relacionados e tarefas, a fim de reduzir a complexidade.
 
Módulos são amplamente utilizados na maioria dos projetos. É mais fácil obter a imagem de um modelo grande se você olhar para os módulos que ele contém e no relacionamento entre eles. Após a interação entre os módulos ser entendida, pode-se começar a descobrir os detalhes dentro de cada um deles. É uma maneira simples e eficiente de se gerenciar a complexidade.
 
Outra razão para se usar módulos está relacionada com a qualidade do código. É amplamente aceito que o código do software deva ter um alto nível de coesão e um baixo nível de acoplamento. Enquanto a coesão começa no nível de classe e método, também pode ser aplicado no nível de módulo. É altamente recomendável agrupar classes relacionadas em módulos, para fornecer a máxima coesão possível. Existem vários tipos de coesão. Duas das mais utilizadas são a coesão comunicacional e coesão funcional. A coesão comunicacional é alcançada quando as peças do módulo operam os mesmos dados. Faz sentido agrupá-los, porque há uma forte relação entre eles. A coesão funcional é alcançada quando todas as partes do módulo trabalham juntas para realizar uma tarefa bem definida. Esse é considerado o melhor tipo de coesão.
 
Utilizar módulos no projeto é uma forma de aumentar a coesão e diminuir o acoplamento. Módulos devem ser compostos de elementos que funcionalmente ou logicamente pertençam a um mesmo conjunto, assegurando a coesão. Eles devem ter interfaces bem definidas que são acessadas ​​por outros módulos. Em vez de chamar três objetos de um módulo, é melhor acessar uma interface, pois reduz o acoplamento. Baixo acoplamento reduz a complexidade e aumenta manutenibilidade. É mais fácil entender o funcionamento de um sistema quando há poucas conexões entre os módulos, que desempenham tarefas bem definidas, do que quando cada módulo tem muitas conexões para todos os outros módulos.
 
Escolha os Módulos que relatem a história do sistema e contenham um conjunto coeso de conceitos. Isso muitas vezes gera baixo acoplamento entre módulos, mas caso não se procure um modo de mudar o modelo para desembaraçar os conceitos, uma visão negligenciada poderá servir como base de um Módulo que poderia trazer elementos de forma significativa. Procure baixo acoplamento no sentido de conceitos que possam ser compreendidos e fundamentados independentemente uns dos outros. Refine o modelo até que as partições estejam de acordo com os conceitos de alto nível do domínio e que o código correspondente seja desacoplado.
 
Dê nomes aos Módulos que se tornem parte da Linguagem Ubíqua. Módulos e seus nomes devem refletir a essência do domínio.
 
Projetistas estão acostumados com a criação de módulos desde o início. Eles são partes comuns de nossos projetos. Depois que o papel do módulo é definido, normalmente permanece inalterado, mesmo que internamente o módulo possa mudar bastante. Recomenda-se ter alguma flexibilidade, permitindo que os módulos evoluam com o projeto, não devendo ser mantidos congelados. É verdade que a refatoração do módulo pode sair mais cara do que uma refatoração da classe, mas quando é encontrado um erro de projeto do módulo, é melhor enfrentá-lo mudando o módulo, para encontrar maneiras de contornar o problema.


## Agregados
 
Os últimos três padrões desse capítulo lidarão com um desafio diferente de modelagem, relacionado ao ciclo de vida dos objetos de domínio. Objetos de domínio passam por um conjunto de estados durante a seu tempo de vida. Eles são criados, colocados em memória, usados ​​em cálculos e destruídos. Em alguns casos, eles são salvos em locais permanentes, como um banco de dados, onde podem ser recuperados tempos mais tarde ou arquivados. Em um determinado momento, esses objetos podem ser completamente apagados do sistema, incluindo o banco de dados e o armazenamento de arquivo.
 
Gerenciar o ciclo de vida de um objeto de domínio constitui um desafio por si só, e se não for feito corretamente, poderá ter um impacto negativo sobre o modelo de domínio. Vamos apresentar três padrões que nos ajudam a lidar com isso. Agregados é um padrão do domínio usado para definir quem é o pai de um objeto e os limites de agregação. Fábricas e Repositórios são dois padrões de projeto que nos ajudam lidar com a criação de objetos e o seu armazenamento. Vamos começar falando sobre os Agregados.
 
Um modelo pode conter um grande número de objetos de domínio. Por mais que tenhamos cuidado na concepção de um projeto, às vezes vemos que muitos objetos estão associados uns aos outros, criando uma complexa rede de relações. Existem vários tipos de associações. Para cada associação do modelo, deve haver mecanismos de software que o imponha. Verdadeiras associações entre objetos de domínio acabam no código, e muitas vezes até mesmo no banco de dados. Uma relação um-a-um entre um cliente e uma conta bancária aberta em seu nome é expressa como uma referência entre dois objetos, implicando num relacionamento entre duas tabelas do banco de dados: uma que mantém os clientes e outra que mantém as contas.
 
Quase sempre o maior desafio dos modelos não é apenas torná-los completos o suficiente, mas torná-los o mais simples e compreensível possível. Na maioria das vezes, custa caro eliminar ou simplificar as relações do modelo, a menos que incorporem conhecimentos profundos do domínio.
 
A associação de um-para-muitos é mais complexa porque envolve muitos objetos que se relacionam. Essa relação pode ser simplificada, transformando-a em uma associação entre um objeto e uma coleção de outros objetos, embora não seja sempre possível.
 
Há associações muitos-para-muitos e um grande número delas é bidirecional. Essa complexidade aumenta demasiadamente, tornando a gestão do ciclo de vida de tais objetos bastante difícil. O número de associações deve ser reduzido tanto quanto possível. Em primeiro lugar, associações que não sejam essenciais para o modelo devem ser removidas. Podem até existir no domínio, mas não são necessárias em nosso modelo, portanto exclua-as. Em segundo lugar, multiplicidade pode ser reduzida pela adição de uma restrição. Se muitos objetos satisfizerem um relacionamento, é possível que apenas um vá fazê-lo se a restrição correta for imposta sobre a relação. Em terceiro lugar, muitas vezes associações bidirecionais podem ser transformadas em uma unidirecional. Cada carro tem um motor, cada motor está incluso em um carro. A relação é bidirecional, mas pode ser facilmente simplificada, considerando que o carro tem um motor, e não o contrário.
 
Depois de reduzir e simplificar as associações entre os objetos, podemos ainda acabar com muitos relacionamentos. Um sistema bancário mantém e processa dados de clientes. Esses dados incluem dados pessoais do cliente, como nome do trabalho, endereço, números de telefone, e uma descrição dos dados da conta: número da conta, o equilíbrio, operações realizadas etc. Quando o sistema arquiva ou exclui completamente a informação sobre um cliente, ele tem que ter certeza de que todas as referências serão removidas. Se muitos objetos mantiverem tais referências, torna-se difícil garantir que todos esses objetos serão excluídos. Além disso, quando algumas alterações dos dados de um cliente são feitas, o sistema tem que se certificar que estará devidamente atualizado ao longo de sua execução, garantindo a integridade dos dados. Isso geralmente é deixado a cargo do banco de dados. As transações são usadas para reforçar a integridade dos dados.
 
Mas se o modelo não foi cuidadosamente projetado, haverá um alto grau de contenção de banco de dados, resultando em um desempenho ruim. Enquanto as transações de banco de dados desempenham um papel vital em tais operações, é desejável resolver alguns dos problemas relacionados à integridade dos dados diretamente no modelo.
 
É necessário também ser capaz de aplicar as invariantes, que são as regras que devem ser mantidas mesmo quando os dados são alterados. Isso é difícil de perceber quando muitos objetos possuem referências a objetos que estão sendo alterados.
 
É difícil garantir a consistência das alterações nos objetos do modelo que possuam associações complexas. Muitas vezes se aplicam invariantes aos objetos fortemente relacionados, não apenas aos discretos. Ainda assim, esquemas cautelosos de lock fazem com que vários usuários interfiram inutilmente uns nos outros, tornando o sistema inutilizável.
 
Portanto, use Agregados. Um Agregado é um grupo de objetos associados que são considerados como uma unidade no que diz respeito a alterações de dados. O Agregado é demarcado por uma fronteira que separa os objetos de dentro dos de fora. Cada Agregado tem uma raiz. A raiz é uma Entidade, sendo o único objeto acessível de fora. A raiz pode conter referências a qualquer um dos objetos agregados; sendo que os demais objetos podem conter referências uns aos outros, mas um objeto de fora pode conter apenas referências para o objeto raiz. Se há outras Entidades dentro do limite, a identidade dessas entidades é local, fazendo sentido somente dentro do agregado.
 
Como é que o agregado garante a integridade dos dados e faz cumprir as invariantes? Uma vez que outros objetos podem conter referências apenas à raiz, significa dizer que eles não podem alterar diretamente os outros objetos do agregado. Tudo o que podem fazer é mudar a raiz, ou pedir que a raiz execute algumas ações. É a raiz que será capaz de mudar os outros objetos, mas isso é uma operação contida dentro do agregado, sendo controlável. Se a raiz é excluída e removida da memória, todos os outros objetos do agregado serão excluídos também, porque não há outro objeto referenciando qualquer um deles. Quando alguma alteração for feita na raiz, que indiretamente afeta outros objetos do agregado, torna-se simples de fazer cumprir as invariantes, pois é a raiz fará isso. É muito mais difícil fazê-lo quando os objetos externos tem acesso direto aos internos para alterá-los. Aplicar as invariantes em tal circunstância envolve colocar alguma lógica nos objetos externos, que é indesejável.
 
É possível para a raiz passar referências transitórias de objetos internos para os externos, com a condição de que os objetos externos não possuam a referência após a conclusão da operação. Uma maneira simples de fazer isso é passar cópias dos Objetos de Valores para objetos externos. Realmente não importa o que aconteça a esses objetos, pois isso não afetará a integridade do agregado de forma alguma.
 
Se os objetos de um Agregado são armazenados em um banco de dados, apenas a raiz deve ser obtida através de consultas. Os outros objetos devem ser obtidos através das associações.
 
Objetos dentro de um agregado podem referenciar as raízes de outros Agregados.
 
A Entidade raiz tem identidade global, e é responsável por manter as invariantes. Entidades internas têm a identidade local.
 
Comporte as Entidades e Objetos de Valor em Agregados, definindo os limites em torno de cada um. Escolha uma Entidade para ser a raiz de cada Agregado e controle todo o acesso aos objetos de dentro da fronteira, através da raiz. Permita que objetos externos mantenham referências unicamente para a raiz. Referências transitórias a membros internos podem ser expostos para uso por meio de uma única operação apenas. Já que a raiz controla o acesso, ele não será pego de surpresa pelas mudanças nos internos. Esse arranjo facilita a aplicação de todas as invariantes nos objetos do Agregado e no Agregado como um todo, em qualquer mudança de estado.
 
Um exemplo simples de uma Agregação é mostrado no seguinte diagrama. O cliente é a raiz do agregado e todos os outros objetos são internos. Se o endereço for necessário, uma cópia dele pode ser passada ​​para os objetos externos.


## Fábricas
 
Entidades e Agregados muitas vezes podem ser grandes e complexos – muito complexos para serem criados no construtor da entidade raiz. De fato, construir um agregado complexo pelo construtor é uma contradição com o que frequentemente acontece no domínio, onde as coisas são criadas por outras (como na eletrônica cujos elementos são criados em linhas de montagem). É como ver uma impressora se construir por ela própria.
 
Quando um objeto cliente quiser criar outro objeto, ele chama seu construtor e, eventualmente, passa alguns parâmetros. Mas quando a construção do objeto é um processo trabalhoso, envolvendo um monte de conhecimento sobre a estrutura interna do objeto, as relações entre os objetos internos e as regras aplicadas a eles, faz com que cada cliente desse objeto conheça coisas específicas sobre o objeto construído. Isso quebra o encapsulamento dos objetos do domínio e dos Agregados. Se o cliente pertence à camada de aplicação, uma parte da camada de domínio foi movida para fora, atrapalhando o projeto inteiro. Na vida real, é como se nos fornecessem a borracha, plástico, metal e silício para construirmos a nossa própria impressora. Não é impossível, mas realmente vale a pena fazer isso?
 
A criação de um objeto pode ser uma grande operação em si, mas as operações de montagem complexa não se encaixam na responsabilidade dos objetos criados. Combinar tais responsabilidades pode produzir projetos desarmoniosos, que são difíceis de entender.
 
Portanto, é necessário introduzir um novo conceito para ajudar a encapsular o processo de criação desse objeto complexo. Esse conceito é chamado de Fábricas. As Fábricas são usadas ​​para encapsular o conhecimento necessário para a criação de objetos, sendo especialmente úteis na criação dos Agregados. Quando a raiz do Agregado for criada, todos os objetos contidos nele serão criados juntos e todas as invariantes serão aplicadas.
 
É importante que o processo de criação seja atômico. Se não for, haverá margem para que o processo de criação seja feito pela metade para alguns objetos, deixando-os em um estado indefinido. Isso é ainda mais verdadeiro para os Agregados. Quando a raiz é criada, é necessário que todos os objetos sujeitos a invariantes sejam criados também. Caso contrário, as invariantes não serão garantidas. Faça dos Objetos de valor imutáveis, para que todos os atributos sejam inicializados e seu estado se torne válido logo. Se um objeto não puder ser criado corretamente, uma exceção deverá ser lançada, certificando-se que um valor inválido não seja retornado.
 
Portanto, transfira a responsabilidade de criação de instâncias de objetos complexos e Agregados para um objeto separado, que pode em si não ter qualquer responsabilidade no modelo de domínio, mas que faça parte do projeto de domínio. Forneça uma interface que encapsule toda montagem complexa e que não exija do cliente referência a classes concretas de objetos que estão sendo instanciados. Crie Agregados inteiros como uma unidade, fazendo valer as suas invariantes.
 
Existem vários padrões de projeto utilizados para implementar Fábricas. O livro Design Patterns de Gamma et all, descreve-os em detalhe e apresenta estes dois padrões, dentre outros: Factory Method e Abstract Factory. Não vamos tentar apresentar os padrões a partir de uma perspectiva de design, mas a partir de uma modelagem de domínio.
 
O Factory Method é um método de objeto que contém e esconde conhecimento necessário para criar outro objeto. Isso é muito útil quando um cliente quer criar um objeto que pertence a um Agregado. A solução é adicionar um método à raiz do agregado que cuide da criação do objeto e garanta todas as invariantes, e que retorne uma referência a esse objeto ou a uma cópia dele.
 
 
O container possui componentes que são de um determinado tipo. Quando esse componente for criado, é necessário que automaticamente ele pertença a um container. O cliente chama o método createComponent(Tipo t) do container, que instancia um novo componente. A classe concreta do componente é determinada com base em seu tipo. Após a sua criação, o componente é adicionado à coleção de componentes contidos no container, e uma cópia é devolvida ao cliente.
 
Há momentos em que a construção de um objeto é mais complexa, ou quando a construção de um objeto envolve a criação de uma série de objetos, por exemplo, a criação de um Agregado. Esconda as construções internas, necessidade maior de um Agregado, através de um objeto Fábrica separado que se dedique a essa tarefa. Consideremos o exemplo de um módulo de programa que calcula a rota que pode ser seguida por um carro desde a partida até o destino, com uma série de restrições. O usuário se autentica no site web que executa o aplicativo e especifica uma das seguintes restrições: o caminho mais curto, o caminho mais rápido e a rota mais barata. As rotas criadas podem ser anotadas com as informações do usuário que precisam ser salvas, para que possam, mais tarde, ser recuperadas quando o cliente acessar o site novamente.
 
 
O gerador do ID de Route é usado para criar uma identidade única para cada rota, que é necessária para uma Entidade.
 
Ao criar uma Fábrica, somos forçados a violar o encapsulamento do objeto, que deve ser feito com cuidado. Sempre que algo muda no objeto que impacte sobre as regras de construção ou em algumas das invariantes, precisamos ter certeza de que a fábrica será atualizada para suportar a nova condição. Fábricas estão intimamente relacionadas com os objetos que são criados. Isso pode ser uma fraqueza, mas também pode ser um ponto forte. Um Agregado contém uma série de objetos que estão intimamente relacionados. A construção da raiz está relacionada com a criação de outros objetos no Agregado. Tem que haver alguma lógica que crie um Agregado. A lógica não pertence, naturalmente, a qualquer um dos objetos, porque é sobre a construção dos objetos. Parece apropriado usar uma classe especial de Fábrica cuja tarefa é criar todo o Agregado, contemplando as regras, as restrições e as invariantes que garantam a sua validade. Os objetos continuarão simples e servirão seus propósitos específicos, sem a desordem da lógica de construção complexa.
 
Fábricas de Entidades e de Objetos de Valor são diferentes. Objetos de Valor geralmente são imutáveis, todos os atributos necessários precisam ser produzidos no momento da criação. Quando o objeto é criado, ele tem que ser válido e definitivo. Isso não vai mudar. Entidades não são imutáveis. Elas podem ser alteradas posteriormente, através da modificação de alguns atributos, desde que sejam respeitadas as invariantes. Outra diferença vem do fato de que as Entidades necessitam de identidade, enquanto os Objetos de Valor não.
 
Há momentos em que uma Fábrica não é necessária e um simples construtor é o suficiente. Use um construtor quando:
 
* A construção não é complicada.
* A criação de um objeto não envolve a criação de outros e todos os atributos necessários são passados através do construtor.
* O cliente está interessado na implementação e talvez queira escolher a Estratégia usada.
* A classe é o tipo. Não há hierarquia envolvida, assim não há necessidade de escolher entre uma lista de implementações concretas.
 
Outra observação importante é que as Fábricas precisam criar novos objetos a partir do zero, ou são obrigadas a reconstituir os objetos que já existam, mas que já foram, provavelmente, persistidos no banco de dados. Trazer as Entidades para a memória a partir do banco de dados envolve um processo completamente diferente do que criar um novo. Uma diferença óbvia é que o objeto trazido do banco não necessita de uma nova identidade, pois já tem uma. Violações nas invariantes são tratadas de forma diferente. Quando um novo objeto é criado a partir do zero, qualquer violação de invariante termina em uma exceção. Não podemos fazer isso com objetos recriados a partir do banco de dados. Os objetos precisam ser reparados de alguma forma, para que eles possam ser funcionais, caso contrário, haverá perda de dados.


## Repositórios
 
No model-driven design, os objetos têm um ciclo de vida começando com a criação e terminando com a eliminação ou arquivamento. Um construtor ou uma Fábrica cuida da criação do objeto. O propósito de criação de objetos é o de permitir usá-los em seguida. Em uma linguagem orientada a objetos, deve-se manter uma referência a um objeto, a fim de utilizá-lo posteriormente. Para ter essa referência, o cliente deve criar o objeto ou obtê-lo de outro, através de uma associação já existente. Por exemplo, para obter um Objeto de Valor de um Agregado, o cliente deve solicitá-lo a partir da raiz do Agregado. O problema agora é que o cliente deve ter uma referência para a raiz. Para aplicações de grande porte, isso se torna um problema, porque é preciso se certificar que o cliente tem sempre uma referência ao objeto necessário ou para outro que tenha uma referência para o objeto respectivo. Usar essa regra no projeto fará com que os objetos mantenham uma série de referências que provavelmente não manteriam originalmente. Esse acoplamento aumenta, criando uma série de associações que não são realmente necessárias.
 
Usar um objeto significa dizer que ele já foi criado. Se o objeto é a raiz de um Agregado, então é uma Entidade, e há chances de que será armazenado em um estado persistente num banco de dados ou noutra forma de armazenamento. Se for um Objeto de Valor, pode ser obtido de uma Entidade através de uma associação. Acontece que uma grande quantidade de objetos pode ser obtida diretamente a partir do banco de dados. Isso resolve o problema de recuperar as referências dos objetos. Quando um cliente quer usar um objeto, ele acessa o banco de dados, recupera o objeto a partir dele e usa-o. Essa parece ser uma rápida e simples solução, mas tem impactos negativos sobre o design.
 
As bases de dados fazem parte da infraestrutura. Uma parca solução seria o cliente estar ciente dos detalhes necessários para acessar um banco de dados, por exemplo, o cliente teria de criar consultas SQL para recuperar os dados desejados. A consulta de banco de dados pode retornar um conjunto de registros, expondo ainda mais os seus detalhes internos. Quando muitos clientes tem que criar objetos diretamente do banco de dados, verifica-se que esse código fica espalhado em todo o domínio. Naquele ponto do modelo, o domínio ficará comprometido, pois terá de lidar com muitos detalhes de infraestrutura em vez de lidar com conceitos do domínio. O que acontece se uma decisão é tomada para mudar o banco de dados subjacente? Todo o código espalhado precisa ser mudado para ser capaz de acessar o novo armazenamento. Quando o código cliente acessa um banco de dados diretamente, é possível que ele recupere um objeto interno de um Agregado. Isso quebra o encapsulamento do Agregado, com consequências desconhecidas.
 
Os clientes precisam de um meio prático de referenciar objetos de domínio preexistentes. Se a infraestrutura ajuda a fazê-lo, os desenvolvedores do cliente podem adicionar mais associações, atrapalhando o modelo. Por outro lado, nada impede de usar consultas para recuperar os dados que necessitam do banco de dados ou para recuperar alguns objetos específicos, em vez de navegar pela raiz do Agregado. A lógica de domínio se move para as consultas do código cliente e as Entidades e Objetos de Valor tornam-se meros containers de informação. A complexidade técnica de aplicar a infraestrutura de acesso ao banco rapidamente deteriora o código do cliente, levando os desenvolvedores a empobrecer a camada de domínio, tornando o modelo irrelevante. O efeito geral é que o foco no domínio é perdido e o design comprometido.
 
Portanto, use um Repositório, cujo objetivo é encapsular toda a lógica necessária para obter referências de objeto. Os objetos de domínio não terão de lidar com a infraestrutura para obter as referências necessárias para outros objetos do domínio. Eles irão acessá-los a partir do Repositório, fazendo com que o modelo recupere seu foco e clareza.
 
O Repositório pode armazenar referências a alguns dos objetos. Quando um objeto é criado, ele pode ser salvo no Repositório, e recuperados de lá para ser usado mais tarde. Se o cliente solicitou um objeto do Repositório e ele não possui tal objeto, poderá então obtê-lo a partir do armazenamento. De qualquer maneira, o Repositório age como um local de armazenamento para objetos globalmente acessíveis.
 
O Repositório pode também incluir uma Estratégia, acessando o armazenamento persistente ou outro, de acordo com a Estratégia especificada. Ele pode usar diferentes locais de armazenamento para diferentes tipos de objetos. O efeito geral é que o modelo de domínio é dissociado da necessidade de armazenar objetos ou as suas referências, tendo que acessar a infraestrutura de persistência subjacente.
 
 
Para cada tipo de objeto que precise de acesso global, crie um objeto que possa fornecer a ilusão de uma coleção em memória de todos os objetos desse tipo. Configure o acesso através de uma interface global bem conhecida. Forneça métodos para adicionar e remover objetos, que irão encapsular a inserção ou remoção no armazenamento de dados. Forneça métodos que selecionem objetos, com base em alguns critérios, retornando-os totalmente instanciados; ou coleções de objetos, cujos valores dos atributos satisfaçam esses critérios, encapsulando a verdadeira consulta na tecnologia de armazenamento. Construa Repositórios somente para as raízes dos Agregados que realmente precisem de acesso direto. Mantenha o cliente focado no modelo, delegando todo o armazenamento e acesso de objetos aos Repositórios.
 
Um Repositório pode conter informações detalhadas de acesso à infraestrutura, mas sua interface deve ser simples. O Repositório deve ter um conjunto de métodos utilizados para recuperar objetos. O cliente chama tal método e passa um ou mais parâmetros que representam os critérios de seleção utilizados para escolher um objeto ou um conjunto de objetos correspondentes. Uma Entidade pode ser facilmente especificada, passando a sua identidade como parâmetro de consulta. Outros critérios de seleção podem ser compostos por um conjunto de atributos do objeto. O Repositório irá comparar todos os objetos com esse conjunto e retornará aqueles que satisfaçam os critérios. A interface do Repositório pode conter métodos usados ​​para fazer alguns cálculos complementares como o número de objetos de um determinado tipo.
 
Pode-se notar que a implementação de um repositório se aproxima bastante da infraestrutura, mas a interface do repositório será modelo de domínio puro.
 
Outra opção seria especificar um critério de seleção como uma Especificação, a qual permite a definição de critérios mais complexos, tais como a seguir:
 
 
Existe uma relação entre a Fábrica e Repositório. Ambos são padrões do model-driven design, e ajudam-nos a gerir o ciclo de vida dos objetos de domínio. Enquanto a Fábrica preocupa-se com a criação de objetos, o Repositório cuida de objetos já existentes. O Repositório pode armazenar os objetos em um cache local, mas, na maioria das vezes, precisa recuperá-los a partir de um armazenamento persistente. Objetos são criados utilizando-se um construtor ou através de Fábricas. Por essa razão, o Repositório pode ser visto como uma Fábrica, porque cria objetos. Não é uma criação a partir do zero, mas uma reconstituição de um objeto que existia. Não devemos misturar um Repositório com uma Fábrica. A Fábrica deve criar novos objetos, enquanto o Repositório deve encontrar objetos já criados. Quando um novo objeto deve ser adicionado ao repositório, deve ser criado primeiro utilizando a Fábrica, para então ser enviado ao Repositório que irá armazená-lo, como no exemplo abaixo.
 
 
Outra forma de diferenciação é que as Fábricas são "de domínio puro", já os repositórios podem conter links para a infraestrutura, por exemplo, banco de dados.
